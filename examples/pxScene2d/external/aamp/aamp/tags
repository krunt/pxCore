!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AAMP2ReceiverMsg	priv_aamp.h	/^	}AAMP2ReceiverMsg;$/;"	t	class:PrivateInstanceAAMP	typeref:struct:PrivateInstanceAAMP::_AAMP2ReceiverMsg
AAMP2ReceiverMsgHdrSz	priv_aamp.h	1368;"	d
AAMP2ReceiverMsgType	priv_aamp.h	/^	enum AAMP2ReceiverMsgType$/;"	g	class:PrivateInstanceAAMP
AAMPAbrBandwidthUpdate	priv_aamp.h	/^	\/* 0 *\/ AAMPAbrBandwidthUpdate,$/;"	e	enum:AAMPAbrType
AAMPAbrFragmentDownloadFailed	priv_aamp.h	/^	\/* 2 *\/ AAMPAbrFragmentDownloadFailed,$/;"	e	enum:AAMPAbrType
AAMPAbrInfo	priv_aamp.h	/^struct AAMPAbrInfo$/;"	s
AAMPAbrManifestDownloadFailed	priv_aamp.h	/^	\/* 1 *\/ AAMPAbrManifestDownloadFailed,$/;"	e	enum:AAMPAbrType
AAMPAbrType	priv_aamp.h	/^enum AAMPAbrType$/;"	g
AAMPAbrUnifiedVideoEngine	priv_aamp.h	/^	\/* 3 *\/ AAMPAbrUnifiedVideoEngine$/;"	e	enum:AAMPAbrType
AAMPAnomalyMessageType	main_aamp.h	/^} AAMPAnomalyMessageType;$/;"	t	typeref:enum:__anon6
AAMPEvent	main_aamp.h	/^	AAMPEvent()$/;"	f	struct:AAMPEvent
AAMPEvent	main_aamp.h	/^	AAMPEvent(AAMPEventType t) : type(t)$/;"	f	struct:AAMPEvent
AAMPEvent	main_aamp.h	/^struct AAMPEvent$/;"	s
AAMPEventListener	main_aamp.h	/^class AAMPEventListener$/;"	c
AAMPEventType	main_aamp.h	/^} AAMPEventType;$/;"	t	typeref:enum:__anon5
AAMPGSTPLAYER_H	aampgstplayer.h	26;"	d
AAMPGstPlayer	aampgstplayer.cpp	/^AAMPGstPlayer::AAMPGstPlayer(PrivateInstanceAAMP *aamp)$/;"	f	class:AAMPGstPlayer
AAMPGstPlayer	aampgstplayer.h	/^class AAMPGstPlayer : public StreamSink$/;"	c
AAMPGstPlayerPriv	aampgstplayer.cpp	/^struct AAMPGstPlayerPriv$/;"	s	file:
AAMPGstPlayer_GetAppSrc	aampgstplayer.cpp	/^static GstElement* AAMPGstPlayer_GetAppSrc(AAMPGstPlayer *_this, StreamOutputFormat format)$/;"	f	file:
AAMPGstPlayer_OnAudioFirstFrameBrcmAudDecoder	aampgstplayer.cpp	/^static void AAMPGstPlayer_OnAudioFirstFrameBrcmAudDecoder(GstElement* object, guint arg0, gpointer arg1,$/;"	f	file:
AAMPGstPlayer_OnGstBufferUnderflowCb	aampgstplayer.cpp	/^static void AAMPGstPlayer_OnGstBufferUnderflowCb(GstElement* object, guint arg0, gpointer arg1,$/;"	f	file:
AAMPGstPlayer_OnGstPtsErrorCb	aampgstplayer.cpp	/^static void AAMPGstPlayer_OnGstPtsErrorCb(GstElement* object, guint arg0, gpointer arg1,$/;"	f	file:
AAMPGstPlayer_OnVideoFirstFrameBrcmVidDecoder	aampgstplayer.cpp	/^static void AAMPGstPlayer_OnVideoFirstFrameBrcmVidDecoder(GstElement* object, guint arg0, gpointer arg1,$/;"	f	file:
AAMPGstPlayer_PlayersinkbinCB	aampgstplayer.cpp	/^static void AAMPGstPlayer_PlayersinkbinCB(GstElement * playersinkbin, gint status,  void* arg)$/;"	f	file:
AAMPGstPlayer_SendPendingEvents	aampgstplayer.cpp	/^static void AAMPGstPlayer_SendPendingEvents(PrivateInstanceAAMP *aamp, AAMPGstPlayerPriv *privateContext, MediaType mediaType, GstClockTime pts)$/;"	f	file:
AAMPGstPlayer_SetupStream	aampgstplayer.cpp	/^static int AAMPGstPlayer_SetupStream(AAMPGstPlayer *_this, int streamId)$/;"	f	file:
AAMPGstPlayer_SignalEOS	aampgstplayer.cpp	/^static void AAMPGstPlayer_SignalEOS(GstElement *source )$/;"	f	file:
AAMPGstPlayer_isVideoDecoder	aampgstplayer.cpp	/^bool AAMPGstPlayer_isVideoDecoder(const char* name, AAMPGstPlayer * _this)$/;"	f
AAMPGstPlayer_isVideoOrAudioDecoder	aampgstplayer.cpp	/^bool AAMPGstPlayer_isVideoOrAudioDecoder(const char* name, AAMPGstPlayer * _this)$/;"	f
AAMPGstPlayer_isVideoSink	aampgstplayer.cpp	/^bool AAMPGstPlayer_isVideoSink(const char* name, AAMPGstPlayer * _this)$/;"	f
AAMPLOG	priv_aamp.h	218;"	d
AAMPLOG_ERR	priv_aamp.h	238;"	d
AAMPLOG_FAILOVER	priv_aamp.h	240;"	d
AAMPLOG_INFO	priv_aamp.h	236;"	d
AAMPLOG_TRACE	priv_aamp.h	235;"	d
AAMPLOG_WARN	priv_aamp.h	237;"	d
AAMPNetworkErrorCurl	priv_aamp.h	/^	\/* 3 *\/ AAMPNetworkErrorCurl$/;"	e	enum:AAMPNetworkErrorType
AAMPNetworkErrorHttp	priv_aamp.h	/^	\/* 1 *\/ AAMPNetworkErrorHttp,$/;"	e	enum:AAMPNetworkErrorType
AAMPNetworkErrorNone	priv_aamp.h	/^	\/* 0 *\/ AAMPNetworkErrorNone,$/;"	e	enum:AAMPNetworkErrorType
AAMPNetworkErrorTimeout	priv_aamp.h	/^	\/* 2 *\/ AAMPNetworkErrorTimeout,$/;"	e	enum:AAMPNetworkErrorType
AAMPNetworkErrorType	priv_aamp.h	/^enum AAMPNetworkErrorType$/;"	g
AAMPStatusType	priv_aamp.h	/^enum AAMPStatusType$/;"	g
AAMPTuneFailure	main_aamp.h	/^}AAMPTuneFailure;$/;"	t	typeref:enum:__anon7
AAMP_ABR_THRESHOLD_SIZE	priv_aamp.h	82;"	d
AAMP_AUDIO_FORMAT_MAP_LEN	fragmentcollector_hls.h	62;"	d
AAMP_BUFFER_MONITOR_GREEN_THRESHOLD	streamabstraction.cpp	45;"	d	file:
AAMP_CDVR_LIVE_OFFSET	priv_aamp.h	66;"	d
AAMP_DEFAULT_BANDWIDTH_BYTES_PREALLOC	streamabstraction.cpp	43;"	d	file:
AAMP_DELAY_BETWEEN_PTS_CHECK_FOR_EOS_ON_UNDERFLOW	aampgstplayer.cpp	98;"	d	file:
AAMP_DRM_CURL_COUNT	priv_aamp.h	62;"	d
AAMP_EVENT_AD_BREAKS_CHANGED	main_aamp.h	/^	AAMP_EVENT_AD_BREAKS_CHANGED,   \/**< Event when content\/ad breaks changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_AD_COMPLETED	main_aamp.h	/^	AAMP_EVENT_AD_COMPLETED,        \/**< Ad playback completed *\/$/;"	e	enum:__anon5
AAMP_EVENT_AD_STARTED	main_aamp.h	/^	AAMP_EVENT_AD_STARTED,          \/**< Ad playback started *\/$/;"	e	enum:__anon5
AAMP_EVENT_AUDIO_TRACKS_CHANGED	main_aamp.h	/^	AAMP_EVENT_AUDIO_TRACKS_CHANGED,\/**< Event when available audio tracks changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_BITRATE_CHANGED	main_aamp.h	/^	AAMP_EVENT_BITRATE_CHANGED,     \/**< Event when bitrate changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_BUFFERING_CHANGED	main_aamp.h	/^	AAMP_EVENT_BUFFERING_CHANGED,   \/**< Event when buffering starts\/ends btw a playback*\/$/;"	e	enum:__anon5
AAMP_EVENT_CC_HANDLE_RECEIVED	main_aamp.h	/^	AAMP_EVENT_CC_HANDLE_RECEIVED,  \/**< Sent when video decoder handle retrieved *\/$/;"	e	enum:__anon5
AAMP_EVENT_DRM_METADATA	main_aamp.h	/^	AAMP_EVENT_DRM_METADATA,$/;"	e	enum:__anon5
AAMP_EVENT_DURATION_CHANGED	main_aamp.h	/^	AAMP_EVENT_DURATION_CHANGED,    \/**< Event when duration changed *\/$/;"	e	enum:__anon5
AAMP_EVENT_ENTERING_LIVE	main_aamp.h	/^	AAMP_EVENT_ENTERING_LIVE,       \/**< Event when live point reached*\/$/;"	e	enum:__anon5
AAMP_EVENT_EOS	main_aamp.h	/^	AAMP_EVENT_EOS,                 \/**< End of stream*\/$/;"	e	enum:__anon5
AAMP_EVENT_JS_EVENT	main_aamp.h	/^	AAMP_EVENT_JS_EVENT,            \/**< Generic event generated by JavaScript binding *\/$/;"	e	enum:__anon5
AAMP_EVENT_MEDIA_METADATA	main_aamp.h	/^	AAMP_EVENT_MEDIA_METADATA,      \/**< Meta-data of asset currently playing*\/$/;"	e	enum:__anon5
AAMP_EVENT_PLAYLIST_INDEXED	main_aamp.h	/^	AAMP_EVENT_PLAYLIST_INDEXED,    \/**< Playlist downloaded and indexed*\/$/;"	e	enum:__anon5
AAMP_EVENT_PROGRESS	main_aamp.h	/^	AAMP_EVENT_PROGRESS,            \/**< Progress event with playback stats. Report interval configurable *\/$/;"	e	enum:__anon5
AAMP_EVENT_REPORT_ANOMALY	main_aamp.h	/^	AAMP_EVENT_REPORT_ANOMALY,       \/**< Playback Anomaly reporting *\/$/;"	e	enum:__anon5
AAMP_EVENT_SPEEDS_CHANGED	main_aamp.h	/^	AAMP_EVENT_SPEEDS_CHANGED,      \/**< Event when supported playback speeds changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_SPEED_CHANGED	main_aamp.h	/^	AAMP_EVENT_SPEED_CHANGED,       \/**< Speed changed internally*\/$/;"	e	enum:__anon5
AAMP_EVENT_STATE_CHANGED	main_aamp.h	/^	AAMP_EVENT_STATE_CHANGED,       \/**< Event when player state changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_TEXT_TRACKS_CHANGED	main_aamp.h	/^	AAMP_EVENT_TEXT_TRACKS_CHANGED, \/**< Event when available test tracks changes *\/$/;"	e	enum:__anon5
AAMP_EVENT_TIMED_METADATA	main_aamp.h	/^	AAMP_EVENT_TIMED_METADATA,      \/**< Meta-data of a subscribed tag parsed from manifest*\/$/;"	e	enum:__anon5
AAMP_EVENT_TUNED	main_aamp.h	/^	AAMP_EVENT_TUNED = 1,           \/**< Tune success*\/$/;"	e	enum:__anon5
AAMP_EVENT_TUNE_FAILED	main_aamp.h	/^	AAMP_EVENT_TUNE_FAILED,         \/**< Tune failure*\/$/;"	e	enum:__anon5
AAMP_IS_LOG_WORTHY_ERROR	priv_aamp.h	230;"	d
AAMP_LIVE_OFFSET	priv_aamp.h	65;"	d
AAMP_LOG_ABR_INFO	priv_aamp.h	229;"	d
AAMP_LOG_DRM_ERROR	priv_aamp.h	228;"	d
AAMP_LOG_NETWORK_ERROR	priv_aamp.h	227;"	d
AAMP_LOG_NETWORK_LATENCY	priv_aamp.h	226;"	d
AAMP_LogLevel	priv_aamp.h	/^enum AAMP_LogLevel$/;"	g
AAMP_MAX_NUM_EVENTS	main_aamp.h	/^	AAMP_MAX_NUM_EVENTS$/;"	e	enum:__anon5
AAMP_MAX_PIPE_DATA_SIZE	priv_aamp.h	64;"	d
AAMP_MAX_SIMULTANEOUS_INSTANCES	main_aamp.cpp	165;"	d	file:
AAMP_MAX_TIME_BW_UNDERFLOWS_TO_TRIGGER_RETUNE_MS	main_aamp.cpp	166;"	d	file:
AAMP_MIN_PTS_UPDATE_INTERVAL	aampgstplayer.cpp	97;"	d	file:
AAMP_NORMAL_PLAY_RATE	main_aamp.h	209;"	d
AAMP_PACKED	priv_aamp.h	51;"	d
AAMP_PACKED	priv_aamp.h	53;"	d
AAMP_SEEK_TO_LIVE_POSITION	priv_aamp.h	105;"	d
AAMP_STALL_CHECK_TOLERANCE	streamabstraction.cpp	44;"	d	file:
AAMP_TRACK_COUNT	priv_aamp.h	61;"	d
AAMP_TUNE_AUTHORISATION_FAILURE	main_aamp.h	/^	AAMP_TUNE_AUTHORISATION_FAILURE,        \/**< Not authorised to view the content*\/$/;"	e	enum:__anon7
AAMP_TUNE_CONTENT_NOT_FOUND	main_aamp.h	/^	AAMP_TUNE_CONTENT_NOT_FOUND,            \/**< The resource was not found at the URL provided (HTTP 404) *\/$/;"	e	enum:__anon7
AAMP_TUNE_CORRUPT_DRM_DATA	main_aamp.h	/^	AAMP_TUNE_CORRUPT_DRM_DATA,             \/**< DRM failure due to corrupt drm data, self heal might clear further errors*\/$/;"	e	enum:__anon7
AAMP_TUNE_DEVICE_NOT_PROVISIONED	main_aamp.h	/^	AAMP_TUNE_DEVICE_NOT_PROVISIONED,       \/**< STB not provisioned\/corrupted; need to re-provision. *\/$/;"	e	enum:__anon7
AAMP_TUNE_DRM_CHALLENGE_FAILED	main_aamp.h	/^	AAMP_TUNE_DRM_CHALLENGE_FAILED,         \/**< DRM key request challenge generation failed *\/$/;"	e	enum:__anon7
AAMP_TUNE_DRM_DATA_BIND_FAILED	main_aamp.h	/^	AAMP_TUNE_DRM_DATA_BIND_FAILED,         \/**< InitData binding with DRM failed *\/$/;"	e	enum:__anon7
AAMP_TUNE_DRM_DECRYPT_FAILED	main_aamp.h	/^	AAMP_TUNE_DRM_DECRYPT_FAILED,           \/**< DRM Decryption Failed for Fragments *\/$/;"	e	enum:__anon7
AAMP_TUNE_DRM_INIT_FAILED	main_aamp.h	/^	AAMP_TUNE_DRM_INIT_FAILED,              \/**< DRM initialization failure *\/$/;"	e	enum:__anon7
AAMP_TUNE_DRM_KEY_UPDATE_FAILED	main_aamp.h	/^	AAMP_TUNE_DRM_KEY_UPDATE_FAILED,        \/**< Failed to process DRM key, see the error code returned from Update() for more info *\/$/;"	e	enum:__anon7
AAMP_TUNE_FAILED_PTS_ERROR	main_aamp.h	/^	AAMP_TUNE_FAILED_PTS_ERROR,             \/**< Playback failed due to PTS error *\/$/;"	e	enum:__anon7
AAMP_TUNE_FAILED_TO_GET_ACCESS_TOKEN	main_aamp.h	/^	AAMP_TUNE_FAILED_TO_GET_ACCESS_TOKEN,   \/**< Failed to get session token from AuthService*\/$/;"	e	enum:__anon7
AAMP_TUNE_FAILED_TO_GET_KEYID	main_aamp.h	/^	AAMP_TUNE_FAILED_TO_GET_KEYID,          \/**< Failed to parse key id from init data*\/$/;"	e	enum:__anon7
AAMP_TUNE_FAILURE_UNKNOWN	main_aamp.h	/^	AAMP_TUNE_FAILURE_UNKNOWN               \/**<  Unknown failure *\/$/;"	e	enum:__anon7
AAMP_TUNE_FRAGMENT_DOWNLOAD_FAILURE	main_aamp.h	/^	AAMP_TUNE_FRAGMENT_DOWNLOAD_FAILURE,    \/**<  When fragment download fails for 5 consecutive fragments*\/$/;"	e	enum:__anon7
AAMP_TUNE_GST_PIPELINE_ERROR	main_aamp.h	/^	AAMP_TUNE_GST_PIPELINE_ERROR,           \/**< Playback failure due to error from GStreamer pipeline or associated plugins *\/$/;"	e	enum:__anon7
AAMP_TUNE_INIT_FAILED	main_aamp.h	/^	AAMP_TUNE_INIT_FAILED,                  \/**< Tune failure due to initialization error*\/$/;"	e	enum:__anon7
AAMP_TUNE_INIT_FRAGMENT_DOWNLOAD_FAILURE	main_aamp.h	/^	AAMP_TUNE_INIT_FRAGMENT_DOWNLOAD_FAILURE, \/**< Unable to download init fragment*\/$/;"	e	enum:__anon7
AAMP_TUNE_INVALID_DRM_KEY	main_aamp.h	/^	AAMP_TUNE_INVALID_DRM_KEY,              \/**< DRM reporting invalid license key *\/$/;"	e	enum:__anon7
AAMP_TUNE_INVALID_MANIFEST_FAILURE	main_aamp.h	/^	AAMP_TUNE_INVALID_MANIFEST_FAILURE,     \/**< Manifest is invalid *\/$/;"	e	enum:__anon7
AAMP_TUNE_LICENCE_REQUEST_FAILED	main_aamp.h	/^	AAMP_TUNE_LICENCE_REQUEST_FAILED,       \/**< DRM license got invalid response *\/$/;"	e	enum:__anon7
AAMP_TUNE_LICENCE_TIMEOUT	main_aamp.h	/^	AAMP_TUNE_LICENCE_TIMEOUT,              \/**< DRM license request timeout *\/$/;"	e	enum:__anon7
AAMP_TUNE_MANIFEST_REQ_FAILED	main_aamp.h	/^	AAMP_TUNE_MANIFEST_REQ_FAILED,          \/**< Tune failure caused by manifest fetch failure*\/$/;"	e	enum:__anon7
AAMP_TUNE_PLAYBACK_STALLED	main_aamp.h	/^	AAMP_TUNE_PLAYBACK_STALLED,             \/**< Playback was stalled due to valid fragments not available in playlist *\/$/;"	e	enum:__anon7
AAMP_TUNE_UNSUPPORTED_STREAM_TYPE	main_aamp.h	/^	AAMP_TUNE_UNSUPPORTED_STREAM_TYPE,      \/**< Unsupported stream type *\/$/;"	e	enum:__anon7
AAMP_TUNE_UNTRACKED_DRM_ERROR	main_aamp.h	/^	AAMP_TUNE_UNTRACKED_DRM_ERROR,          \/**<  DRM error*\/$/;"	e	enum:__anon7
AAMP_VIDEO_FORMAT_MAP_LEN	fragmentcollector_hls.h	63;"	d
ABRProfileChanged	fragmentcollector_hls.cpp	/^void TrackState::ABRProfileChanged()$/;"	f	class:TrackState
ABRProfileChanged	fragmentcollector_mpd.cpp	/^	void ABRProfileChanged(void)$/;"	f	class:MediaStreamContext
ADAPTATION_FIELD_PRESENT	tsprocessor.cpp	128;"	d	file:
ALL_FRAMES	tsprocessor.cpp	106;"	d	file:
ANOMALY_ERROR	main_aamp.h	/^	ANOMALY_ERROR,$/;"	e	enum:__anon6
ANOMALY_TRACE	main_aamp.h	/^	ANOMALY_TRACE$/;"	e	enum:__anon6
ANOMALY_WARNING	main_aamp.h	/^	ANOMALY_WARNING,$/;"	e	enum:__anon6
ARRAY_SIZE	main_aamp.cpp	108;"	d	file:
AampLogManager	priv_aamp.h	/^	AampLogManager() : aampLoglevel(eLOGLEVEL_WARN), info(false), debug(false), trace(false), gst(false), curl(false), progress(false), failover(false)$/;"	f	class:AampLogManager
AampLogManager	priv_aamp.h	/^class AampLogManager$/;"	c
AbortWaitForCachedFragment	streamabstraction.cpp	/^void MediaTrack::AbortWaitForCachedFragment( bool immediate)$/;"	f	class:MediaTrack
AddAttributesToNode	fragmentcollector_mpd.cpp	/^static void AddAttributesToNode(xmlTextReaderPtr *reader, Node *node)$/;"	f	file:
AddCustomHTTPHeader	main_aamp.cpp	/^void PlayerInstanceAAMP::AddCustomHTTPHeader(std::string headerName, std::vector<std::string> headerValue)$/;"	f	class:PlayerInstanceAAMP
AddCustomHTTPHeader	main_aamp.cpp	/^void PrivateInstanceAAMP::AddCustomHTTPHeader(std::string headerName, std::vector<std::string> headerValue)$/;"	f	class:PrivateInstanceAAMP
AddEventListener	main_aamp.cpp	/^void PlayerInstanceAAMP::AddEventListener(AAMPEventType eventType, AAMPEventListener* eventListener)$/;"	f	class:PlayerInstanceAAMP
AddEventListener	main_aamp.cpp	/^void PrivateInstanceAAMP::AddEventListener(AAMPEventType eventType, AAMPEventListener* eventListener)$/;"	f	class:PrivateInstanceAAMP
AddIdleTask	main_aamp.cpp	/^void PrivateInstanceAAMP::AddIdleTask(IdleTask task, void* arg)$/;"	f	class:PrivateInstanceAAMP
AsyncEventDescriptor	main_aamp.cpp	/^struct AsyncEventDescriptor$/;"	s	file:
AsyncEventDestroyNotify	main_aamp.cpp	/^static void AsyncEventDestroyNotify(gpointer user_data)$/;"	f	file:
AttributeNameMatch	fragmentcollector_hls.cpp	/^static bool AttributeNameMatch(const char *attrNamePtr, const char *targetAttrNameCString)$/;"	f	file:
AudioType	priv_aamp.h	/^enum AudioType$/;"	g
AuthTokenErrors	main_aamp.h	/^enum AuthTokenErrors {$/;"	g
BASE16_H	base16.h	21;"	d
BASE64_H	_base64.h	21;"	d
BITRATE_ALLOWED_VARIATION_BAND	priv_aamp.h	81;"	d
BOOLSTR	fragmentcollector_hls.cpp	64;"	d	file:
BOOLSTR	fragmentcollector_hls.h	56;"	d
BUFFER_POOL_SIZE	tsprocessor.cpp	862;"	d	file:
BUFFER_STATUS_GREEN	StreamAbstractionAAMP.h	/^	BUFFER_STATUS_GREEN,  \/**< Healthy state, where buffering is close to being maxed out *\/$/;"	e	enum:BufferHealthStatus
BUFFER_STATUS_RED	StreamAbstractionAAMP.h	/^	BUFFER_STATUS_RED     \/**< Failed state, where buffers have run dry, and player experiences underrun\/stalled video *\/$/;"	e	enum:BufferHealthStatus
BUFFER_STATUS_YELLOW	StreamAbstractionAAMP.h	/^	BUFFER_STATUS_YELLOW, \/**< Danger  state, where buffering is close to being exhausted *\/$/;"	e	enum:BufferHealthStatus
B_FRAME	tsprocessor.cpp	105;"	d	file:
Bandwidth	fragmentcollector_mpd.cpp	/^	uint32_t Bandwidth;$/;"	m	struct:FragmentDescriptor	file:
BlockUntilGstreamerWantsData	main_aamp.cpp	/^void PrivateInstanceAAMP::BlockUntilGstreamerWantsData(void(*cb)(void), int periodMs, int track)$/;"	f	class:PrivateInstanceAAMP
BufferHealthMonitor	streamabstraction.cpp	/^static void* BufferHealthMonitor(void* user_data)$/;"	f	file:
BufferHealthStatus	StreamAbstractionAAMP.h	/^enum BufferHealthStatus$/;"	g
CHAR_CR	fragmentcollector_hls.cpp	62;"	d	file:
CHAR_CR	fragmentcollector_hls.h	54;"	d
CHAR_LF	fragmentcollector_hls.cpp	63;"	d	file:
CHAR_LF	fragmentcollector_hls.h	55;"	d
COMCAST_DRM_INFO_ID	fragmentcollector_mpd.cpp	73;"	d	file:
CONTAINS_PAYLOAD	tsprocessor.cpp	122;"	d	file:
CURL_FRAGMENT_DL_TIMEOUT	priv_aamp.h	67;"	d
CURL_MANIFEST_DL_TIMEOUT	priv_aamp.h	68;"	d
CacheFragment	fragmentcollector_mpd.cpp	/^	bool CacheFragment(const char *fragmentUrl, unsigned int curlInstance, double position, double duration, const char *range = NULL, bool initSegment= false, bool discontinuity = false$/;"	f	class:MediaStreamContext
CachedFragment	StreamAbstractionAAMP.h	/^struct CachedFragment$/;"	s
ChannelInfo	main_aamp.cpp	/^struct ChannelInfo$/;"	s	file:
CheckABREnabled	priv_aamp.h	/^	bool CheckABREnabled(void) { return mABREnabled; }$/;"	f	class:PrivateInstanceAAMP
CheckForInitalClearPeriod	fragmentcollector_mpd.cpp	/^bool PrivateStreamAbstractionMPD::CheckForInitalClearPeriod()$/;"	f	class:PrivateStreamAbstractionMPD
CheckForPlaybackStall	streamabstraction.cpp	/^void StreamAbstractionAAMP::CheckForPlaybackStall(bool fragmentParsed)$/;"	f	class:StreamAbstractionAAMP
CheckForProfileChange	streamabstraction.cpp	/^void StreamAbstractionAAMP::CheckForProfileChange(void)$/;"	f	class:StreamAbstractionAAMP
CheckForRampDownProfile	streamabstraction.cpp	/^bool StreamAbstractionAAMP::CheckForRampDownProfile(long http_error)$/;"	f	class:StreamAbstractionAAMP
CheckIfPlayerRunningDry	streamabstraction.cpp	/^bool StreamAbstractionAAMP::CheckIfPlayerRunningDry()$/;"	f	class:StreamAbstractionAAMP
CheckUserProfileChangeReq	streamabstraction.cpp	/^void StreamAbstractionAAMP::CheckUserProfileChangeReq(void)$/;"	f	class:StreamAbstractionAAMP
ClassicProfilerBucketType	priv_aamp.h	/^ }ClassicProfilerBucketType;$/;"	t	typeref:enum:__anon24
ClearPlaylistCache	main_aamp.cpp	/^void PrivateInstanceAAMP::ClearPlaylistCache()$/;"	f	class:PrivateInstanceAAMP
ClearProtectionEvent	aampgstplayer.cpp	/^void AAMPGstPlayer::ClearProtectionEvent()$/;"	f	class:AAMPGstPlayer
ClearProtectionEvent	main_aamp.h	/^	virtual void ClearProtectionEvent() {};$/;"	f	class:StreamSink
ClosePipeSession	main_aamp.cpp	/^void PrivateInstanceAAMP::ClosePipeSession()$/;"	f	class:PrivateInstanceAAMP
Configure	aampgstplayer.cpp	/^void AAMPGstPlayer::Configure(StreamOutputFormat format, StreamOutputFormat audioFormat, bool bESChangeStatus)$/;"	f	class:AAMPGstPlayer
ContentType	priv_aamp.h	/^enum ContentType$/;"	g
ContentType_CAMERA	priv_aamp.h	/^	ContentType_CAMERA,         \/**< 6 - Camera *\/$/;"	e	enum:ContentType
ContentType_CDVR	priv_aamp.h	/^	ContentType_CDVR,           \/**< 1 - CDVR *\/$/;"	e	enum:ContentType
ContentType_DVR	priv_aamp.h	/^	ContentType_DVR,            \/**< 7 - DVR *\/$/;"	e	enum:ContentType
ContentType_EAS	priv_aamp.h	/^	ContentType_EAS,            \/**< 5 - EAS *\/$/;"	e	enum:ContentType
ContentType_IPDVR	priv_aamp.h	/^	ContentType_IPDVR,          \/**< 8 - IPDVR *\/$/;"	e	enum:ContentType
ContentType_IVOD	priv_aamp.h	/^	ContentType_IVOD,           \/**< 4 - IVOD *\/$/;"	e	enum:ContentType
ContentType_LINEAR	priv_aamp.h	/^	ContentType_LINEAR,         \/**< 3 - Linear *\/$/;"	e	enum:ContentType
ContentType_MAX	priv_aamp.h	/^	ContentType_MAX             \/**< 11 - Type Count*\/$/;"	e	enum:ContentType
ContentType_MDVR	priv_aamp.h	/^	ContentType_MDVR,           \/**< 8 - MDVR *\/$/;"	e	enum:ContentType
ContentType_PPV	priv_aamp.h	/^	ContentType_PPV,            \/**< 10 - PPV *\/$/;"	e	enum:ContentType
ContentType_UNKNOWN	priv_aamp.h	/^	ContentType_UNKNOWN,        \/**< 0 - Unknown type *\/$/;"	e	enum:ContentType
ContentType_VOD	priv_aamp.h	/^	ContentType_VOD,            \/**< 2 - VOD *\/$/;"	e	enum:ContentType
CreateDRMSession	fragmentcollector_mpd.cpp	/^void *CreateDRMSession(void *arg)$/;"	f
CreatePipeline	aampgstplayer.cpp	/^bool AAMPGstPlayer::CreatePipeline()$/;"	f	class:AAMPGstPlayer
CurlCallbackContext	main_aamp.cpp	/^struct CurlCallbackContext$/;"	s	file:
CurlInit	main_aamp.cpp	/^void PrivateInstanceAAMP::CurlInit(int startIdx, unsigned int instanceCount)$/;"	f	class:PrivateInstanceAAMP
CurlTerm	main_aamp.cpp	/^void PrivateInstanceAAMP::CurlTerm(int startIdx, unsigned int instanceCount)$/;"	f	class:PrivateInstanceAAMP
DEBUG	tsprocessor.cpp	62;"	d	file:
DEBUG	tsprocessor.cpp	66;"	d	file:
DEBUG_DEMUX	tsprocessor.cpp	134;"	d	file:
DEBUG_DEMUX	tsprocessor.cpp	146;"	d	file:
DEFAULT_ABR_CACHE_LENGTH	priv_aamp.h	84;"	d
DEFAULT_ABR_CACHE_LIFE	priv_aamp.h	83;"	d
DEFAULT_ABR_NW_CONSISTENCY_CNT	priv_aamp.h	87;"	d
DEFAULT_ABR_OUTLIER	priv_aamp.h	85;"	d
DEFAULT_ABR_SKIP_DURATION	priv_aamp.h	86;"	d
DEFAULT_BUFFERING_MAX_CNT	aampgstplayer.cpp	96;"	d	file:
DEFAULT_BUFFERING_MAX_MS	aampgstplayer.cpp	95;"	d	file:
DEFAULT_BUFFERING_QUEUED_BYTES_MIN	aampgstplayer.cpp	93;"	d	file:
DEFAULT_BUFFERING_QUEUED_FRAMES_MIN	aampgstplayer.cpp	94;"	d	file:
DEFAULT_BUFFERING_TO_MS	aampgstplayer.cpp	92;"	d	file:
DEFAULT_BUFFER_HEALTH_MONITOR_DELAY	priv_aamp.h	94;"	d
DEFAULT_BUFFER_HEALTH_MONITOR_INTERVAL	priv_aamp.h	95;"	d
DEFAULT_CACHED_FRAGMENTS_PER_TRACK	priv_aamp.h	93;"	d
DEFAULT_CURL_CONNECTTIMEOUT	priv_aamp.h	70;"	d
DEFAULT_CURL_LOW_SPEED_LIMIT	priv_aamp.h	73;"	d
DEFAULT_CURL_LOW_SPEED_TIME	priv_aamp.h	74;"	d
DEFAULT_CURL_TIMEOUT	priv_aamp.h	69;"	d
DEFAULT_INIT_BITRATE	priv_aamp.h	78;"	d
DEFAULT_INIT_BITRATE_4K	priv_aamp.h	79;"	d
DEFAULT_INTERVAL_BETWEEN_MPD_UPDATES_MS	fragmentcollector_mpd.cpp	67;"	d	file:
DEFAULT_INTERVAL_BETWEEN_PLAYLIST_UPDATES_MS	priv_aamp.h	75;"	d
DEFAULT_MINIMUM_CACHE_VOD_SECONDS	priv_aamp.h	80;"	d
DEFAULT_REPORT_PROGRESS_INTERVAL	priv_aamp.h	101;"	d
DEFAULT_STALL_DETECTION_TIMEOUT	priv_aamp.h	98;"	d
DEFAULT_STALL_ERROR_CODE	priv_aamp.h	97;"	d
DEFAULT_THROTTLE_DELAY_FOR_DISCONTINUITY_MS	tsprocessor.cpp	114;"	d	file:
DEFAULT_THROTTLE_DELAY_IGNORED_MS	tsprocessor.cpp	113;"	d	file:
DEFAULT_THROTTLE_MAX_DELAY_MS	tsprocessor.cpp	111;"	d	file:
DEFAULT_THROTTLE_MAX_DIFF_SEGMENTS_MS	tsprocessor.cpp	112;"	d	file:
DEFAULT_VIDEO_RECTANGLE	aampgstplayer.cpp	88;"	d	file:
DEFAULT_VIDEO_RECTANGLE	aampgstplayer.cpp	90;"	d	file:
DEFER_DRM_LIC_OFFSET_FROM_START	streamabstraction.cpp	46;"	d	file:
DEFER_DRM_LIC_OFFSET_TO_UPPER_BOUND	streamabstraction.cpp	47;"	d	file:
DEF_LICENSE_REQ_RETRY_WAIT_TIME	priv_aamp.h	91;"	d
DISCONTINUITY_DISCARD_TOLERANCE_SECONDS	fragmentcollector_hls.cpp	73;"	d	file:
DRMSystems	main_aamp.h	/^enum DRMSystems$/;"	g
DRM_IV_LEN	fragmentcollector_hls.cpp	69;"	d	file:
DRM_IV_LEN	fragmentcollector_hls.h	61;"	d
DUMP_PACKET	tsprocessor.cpp	85;"	d	file:
DeFog	main_aamp.cpp	/^static void DeFog(char *dst)$/;"	f	file:
Demuxer	tsprocessor.cpp	/^	Demuxer(class PrivateInstanceAAMP *aamp,MediaType type)$/;"	f	class:Demuxer
Demuxer	tsprocessor.cpp	/^class Demuxer$/;"	c	file:
DestroyPipeline	aampgstplayer.cpp	/^void AAMPGstPlayer::DestroyPipeline()$/;"	f	class:AAMPGstPlayer
DisableDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::DisableDownloads(void)$/;"	f	class:PrivateInstanceAAMP
DisconnectCallbacks	aampgstplayer.cpp	/^void AAMPGstPlayer::DisconnectCallbacks()$/;"	f	class:AAMPGstPlayer
Discontinuity	aampgstplayer.cpp	/^bool AAMPGstPlayer::Discontinuity(MediaType type)$/;"	f	class:AAMPGstPlayer
Discontinuity	main_aamp.cpp	/^bool PrivateInstanceAAMP::Discontinuity(MediaType track)$/;"	f	class:PrivateInstanceAAMP
DiscontinuityIndexNode	fragmentcollector_hls.h	/^struct DiscontinuityIndexNode$/;"	s
DownloadsAreEnabled	main_aamp.cpp	/^bool PrivateInstanceAAMP::DownloadsAreEnabled(void)$/;"	f	class:PrivateInstanceAAMP
DrmDecrypt	fragmentcollector_hls.cpp	/^DrmReturn TrackState::DrmDecrypt( CachedFragment * cachedFragment, ProfilerBucketType bucketTypeFragmentDecrypt)$/;"	f	class:TrackState
DrmSessionParams	fragmentcollector_mpd.cpp	/^struct DrmSessionParams$/;"	s	file:
DumpIndex	fragmentcollector_hls.cpp	/^static void DumpIndex(TrackState *trackState)$/;"	f	file:
DumpProfiles	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::DumpProfiles(void)$/;"	f	class:StreamAbstractionAAMP_HLS
DumpProfiles	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::DumpProfiles(void)$/;"	f	class:StreamAbstractionAAMP_MPD
DumpStatus	aampgstplayer.cpp	/^void AAMPGstPlayer::DumpStatus(void)$/;"	f	class:AAMPGstPlayer
DumpStatus	main_aamp.h	/^	virtual void DumpStatus(void){}$/;"	f	class:StreamSink
EAS_CURL_CONNECTTIMEOUT	priv_aamp.h	72;"	d
EAS_CURL_TIMEOUT	priv_aamp.h	71;"	d
ERROR	tsprocessor.cpp	71;"	d	file:
ERROR	tsprocessor.cpp	75;"	d	file:
ERROR	tsprocessor.cpp	80;"	d	file:
E_AAMP2Receiver_EVENTS	priv_aamp.h	/^	    E_AAMP2Receiver_EVENTS,$/;"	e	enum:PrivateInstanceAAMP::AAMP2ReceiverMsgType
E_AAMP2Receiver_MsgMAX	priv_aamp.h	/^	    E_AAMP2Receiver_MsgMAX$/;"	e	enum:PrivateInstanceAAMP::AAMP2ReceiverMsgType
E_AAMP2Receiver_TUNETIME	priv_aamp.h	/^	    E_AAMP2Receiver_TUNETIME,$/;"	e	enum:PrivateInstanceAAMP::AAMP2ReceiverMsgType
EnableDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::EnableDownloads()$/;"	f	class:PrivateInstanceAAMP
Enabled	streamabstraction.cpp	/^bool MediaTrack::Enabled()$/;"	f	class:MediaTrack
EndOfStreamReached	aampgstplayer.cpp	/^void AAMPGstPlayer::EndOfStreamReached(MediaType type)$/;"	f	class:AAMPGstPlayer
EndOfStreamReached	main_aamp.cpp	/^void PrivateInstanceAAMP::EndOfStreamReached(MediaType mediaType)$/;"	f	class:PrivateInstanceAAMP
EndOfStreamReached	main_aamp.h	/^	virtual void EndOfStreamReached(MediaType mediaType){}$/;"	f	class:StreamSink
EndTimeReached	main_aamp.cpp	/^void PrivateInstanceAAMP::EndTimeReached(MediaType mediaType)$/;"	f	class:PrivateInstanceAAMP
FATAL	tsprocessor.cpp	76;"	d	file:
FATAL	tsprocessor.cpp	81;"	d	file:
FIXED_FRAME_RATE	tsprocessor.cpp	89;"	d	file:
FLUSH_ALL_SLICE_BITS	tsprocessor.cpp	3973;"	d	file:
FLUSH_SLICE_BITS	tsprocessor.cpp	3966;"	d	file:
FOG_FRAG_BW_DELIMITER	fragmentcollector_hls.h	53;"	d
FOG_FRAG_BW_IDENTIFIER	fragmentcollector_hls.h	51;"	d
FOG_FRAG_BW_IDENTIFIER_LEN	fragmentcollector_hls.h	52;"	d
FOG_REASON_STRING	main_aamp.cpp	1489;"	d	file:
FORMAT_AUDIO_ES_AAC	main_aamp.h	/^	FORMAT_AUDIO_ES_AAC,    \/**< AAC Audio Elementary Stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_AUDIO_ES_AC3	main_aamp.h	/^	FORMAT_AUDIO_ES_AC3,    \/**< AC3 Audio Elementary Stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_AUDIO_ES_ATMOS	main_aamp.h	/^	FORMAT_AUDIO_ES_ATMOS,   \/**< ATMOS Audio stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_AUDIO_ES_EC3	main_aamp.h	/^	FORMAT_AUDIO_ES_EC3,    \/**< Dolby Digital Plus Elementary Stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_INVALID	main_aamp.h	/^	FORMAT_INVALID,         \/**< Invalid format *\/$/;"	e	enum:StreamOutputFormat
FORMAT_ISO_BMFF	main_aamp.h	/^	FORMAT_ISO_BMFF,        \/**< ISO Base Media File format *\/$/;"	e	enum:StreamOutputFormat
FORMAT_MPEGTS	main_aamp.h	/^	FORMAT_MPEGTS,          \/**< MPEG Transport Stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_NONE	main_aamp.h	/^	FORMAT_NONE             \/**< Unknown Format *\/$/;"	e	enum:StreamOutputFormat
FORMAT_VIDEO_ES_H264	main_aamp.h	/^	FORMAT_VIDEO_ES_H264,   \/**< MPEG-4 Video Elementary Stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_VIDEO_ES_HEVC	main_aamp.h	/^    FORMAT_VIDEO_ES_HEVC,   \/**< HEVC video elementary stream *\/$/;"	e	enum:StreamOutputFormat
FORMAT_VIDEO_ES_MPEG2	main_aamp.h	/^	FORMAT_VIDEO_ES_MPEG2,  \/**< MPEG-2 Video Elementary Stream *\/$/;"	e	enum:StreamOutputFormat
FRAGMENTCOLLECTOR_HLS_H	fragmentcollector_hls.h	37;"	d
FRAGMENT_DOWNLOAD_WARNING_THRESHOLD	priv_aamp.h	99;"	d
FRAME_HEIGHT_MAX	tsprocessor.cpp	91;"	d	file:
FRAME_WIDTH_MAX	tsprocessor.cpp	90;"	d	file:
FetchAndInjectInitialization	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::FetchAndInjectInitialization(bool discontinuity)$/;"	f	class:PrivateStreamAbstractionMPD
FetchFragment	fragmentcollector_hls.cpp	/^void TrackState::FetchFragment()$/;"	f	class:TrackState
FetchFragment	fragmentcollector_mpd.cpp	/^bool PrivateStreamAbstractionMPD::FetchFragment(MediaStreamContext *pMediaStreamContext, std::string media, double fragmentDuration, bool isInitializationSegment, unsigned int curlInstance, bool discontinuity)$/;"	f	class:PrivateStreamAbstractionMPD
FetchFragmentHelper	fragmentcollector_hls.cpp	/^bool TrackState::FetchFragmentHelper(long &http_error, bool &decryption_error)$/;"	f	class:TrackState
FetchInitFragment	fragmentcollector_hls.cpp	/^bool TrackState::FetchInitFragment(long &http_code)$/;"	f	class:TrackState
FetchPlaylist	fragmentcollector_hls.cpp	/^void TrackState::FetchPlaylist()$/;"	f	class:TrackState
FetcherLoop	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::FetcherLoop()$/;"	f	class:PrivateStreamAbstractionMPD
FindMediaForSequenceNumber	fragmentcollector_hls.cpp	/^char *TrackState::FindMediaForSequenceNumber()$/;"	f	class:TrackState
FindTimedMetadata	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::FindTimedMetadata(MPD* mpd, Node* root)$/;"	f	class:PrivateStreamAbstractionMPD
Flush	aampgstplayer.cpp	/^void AAMPGstPlayer::Flush(double position, int rate)$/;"	f	class:AAMPGstPlayer
Flush	aampgstplayer.cpp	/^void AAMPGstPlayer::Flush(void)$/;"	f	class:AAMPGstPlayer
Flush	main_aamp.h	/^	virtual void Flush(double position = 0, int rate = AAMP_NORMAL_PLAY_RATE){}$/;"	f	class:StreamSink
FlushIndex	fragmentcollector_hls.cpp	/^void TrackState::FlushIndex()$/;"	f	class:TrackState
FormatMap	fragmentcollector_hls.cpp	/^struct FormatMap$/;"	s	file:
FragmentCollector	fragmentcollector_hls.cpp	/^static void *FragmentCollector(void *arg)$/;"	f	file:
FragmentCollector	fragmentcollector_mpd.cpp	/^static void * FragmentCollector(void *arg)$/;"	f	file:
FragmentDescriptor	fragmentcollector_mpd.cpp	/^struct FragmentDescriptor$/;"	s	file:
FragmentDownloadParams	fragmentcollector_mpd.cpp	/^struct FragmentDownloadParams$/;"	s	file:
FragmentDownloader	fragmentcollector_mpd.cpp	/^void * FragmentDownloader(void *arg)$/;"	f
FragmentInjector	streamabstraction.cpp	/^static void *FragmentInjector(void *arg)$/;"	f	file:
GSTPLAYERSINKBIN_EVENT_ERROR_AUDIO_PTS	aampgstplayer.cpp	81;"	d	file:
GSTPLAYERSINKBIN_EVENT_ERROR_AUDIO_UNDERFLOW	aampgstplayer.cpp	79;"	d	file:
GSTPLAYERSINKBIN_EVENT_ERROR_VIDEO_PTS	aampgstplayer.cpp	80;"	d	file:
GSTPLAYERSINKBIN_EVENT_ERROR_VIDEO_UNDERFLOW	aampgstplayer.cpp	78;"	d	file:
GSTPLAYERSINKBIN_EVENT_FIRST_AUDIO_FRAME	aampgstplayer.cpp	77;"	d	file:
GSTPLAYERSINKBIN_EVENT_FIRST_VIDEO_FRAME	aampgstplayer.cpp	76;"	d	file:
GSTPLAYERSINKBIN_EVENT_HAVE_AUDIO	aampgstplayer.cpp	75;"	d	file:
GSTPLAYERSINKBIN_EVENT_HAVE_VIDEO	aampgstplayer.cpp	74;"	d	file:
GST_ELEMENT_GET_STATE_RETRY_CNT_MAX	aampgstplayer.cpp	71;"	d	file:
GST_PLAY_FLAG_AUDIO	aampgstplayer.cpp	/^	GST_PLAY_FLAG_AUDIO = (1 << 1), \/\/!< 0x002$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_BUFFERING	aampgstplayer.cpp	/^	GST_PLAY_FLAG_BUFFERING = (1 << 8), \/\/!< 0x100$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_DEINTERLACE	aampgstplayer.cpp	/^	GST_PLAY_FLAG_DEINTERLACE = (1 << 9), \/\/!< 0x200$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_DOWNLOAD	aampgstplayer.cpp	/^	GST_PLAY_FLAG_DOWNLOAD = (1 << 7), \/\/!< 0x080$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_NATIVE_AUDIO	aampgstplayer.cpp	/^	GST_PLAY_FLAG_NATIVE_AUDIO = (1 << 5), \/\/!< 0x020$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_NATIVE_VIDEO	aampgstplayer.cpp	/^	GST_PLAY_FLAG_NATIVE_VIDEO = (1 << 6), \/\/!< 0x040$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_SOFT_COLORBALANCE	aampgstplayer.cpp	/^	GST_PLAY_FLAG_SOFT_COLORBALANCE = (1 << 10) \/\/!< 0x400$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_SOFT_VOLUME	aampgstplayer.cpp	/^	GST_PLAY_FLAG_SOFT_VOLUME = (1 << 4), \/\/!< 0x010$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_TEXT	aampgstplayer.cpp	/^	GST_PLAY_FLAG_TEXT = (1 << 2), \/\/!< 0x004$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_VIDEO	aampgstplayer.cpp	/^	GST_PLAY_FLAG_VIDEO = (1 << 0), \/\/!< 0x001$/;"	e	enum:__anon3	file:
GST_PLAY_FLAG_VIS	aampgstplayer.cpp	/^	GST_PLAY_FLAG_VIS = (1 << 3), \/\/!< 0x008$/;"	e	enum:__anon3	file:
GetABRManager	StreamAbstractionAAMP.h	/^	ABRManager& GetABRManager() {$/;"	f	class:StreamAbstractionAAMP
GetAttributeValueString	fragmentcollector_hls.cpp	/^static char * GetAttributeValueString(char *valuePtr, char *fin)$/;"	f	file:
GetAudioBitrate	main_aamp.cpp	/^long PlayerInstanceAAMP::GetAudioBitrate(void)$/;"	f	class:PlayerInstanceAAMP
GetAudioBitrate	streamabstraction.cpp	/^long StreamAbstractionAAMP::GetAudioBitrate(void)$/;"	f	class:StreamAbstractionAAMP
GetAudioBitrates	fragmentcollector_hls.cpp	/^std::vector<long> StreamAbstractionAAMP_HLS::GetAudioBitrates(void)$/;"	f	class:StreamAbstractionAAMP_HLS
GetAudioBitrates	fragmentcollector_mpd.cpp	/^std::vector<long> PrivateStreamAbstractionMPD::GetAudioBitrates(void)$/;"	f	class:PrivateStreamAbstractionMPD
GetAudioBitrates	fragmentcollector_mpd.cpp	/^std::vector<long> StreamAbstractionAAMP_MPD::GetAudioBitrates(void)$/;"	f	class:StreamAbstractionAAMP_MPD
GetAudioBitrates	main_aamp.cpp	/^std::vector<long> PlayerInstanceAAMP::GetAudioBitrates(void)$/;"	f	class:PlayerInstanceAAMP
GetAudioVolume	main_aamp.cpp	/^int PlayerInstanceAAMP::GetAudioVolume(void)$/;"	f	class:PlayerInstanceAAMP
GetBWIndex	fragmentcollector_hls.cpp	/^int StreamAbstractionAAMP_HLS::GetBWIndex(long bitrate)$/;"	f	class:StreamAbstractionAAMP_HLS
GetBWIndex	fragmentcollector_mpd.cpp	/^int PrivateStreamAbstractionMPD::GetBWIndex(long bitrate)$/;"	f	class:PrivateStreamAbstractionMPD
GetBWIndex	fragmentcollector_mpd.cpp	/^int StreamAbstractionAAMP_MPD::GetBWIndex(long bitrate)$/;"	f	class:StreamAbstractionAAMP_MPD
GetBitrateInfoFromCustomMpd	fragmentcollector_mpd.cpp	/^static void GetBitrateInfoFromCustomMpd(IAdaptationSet *adaptationSet, std::vector<Representation *>& representations )$/;"	f	file:
GetBufferHealthStatus	StreamAbstractionAAMP.h	/^	BufferHealthStatus GetBufferHealthStatus() { return bufferStatus; };$/;"	f	class:MediaTrack
GetBufferHealthStatusString	streamabstraction.cpp	/^const char* MediaTrack::GetBufferHealthStatusString(BufferHealthStatus status)$/;"	f	class:MediaTrack
GetClassicTuneTimeInfo	priv_aamp.h	/^	void GetClassicTuneTimeInfo(bool success, int tuneRetries, int firstTuneType, long long playerLoadTime, int streamType, bool isLive,unsigned int durationinSec, char *TuneTimeInfoStr)$/;"	f	class:ProfileEventAAMP
GetCompletionTimeForFragment	fragmentcollector_hls.cpp	/^static double GetCompletionTimeForFragment(const TrackState *trackState, long long mediaSequenceNumber)$/;"	f	file:
GetContentTypString	main_aamp.cpp	/^std::string  PrivateInstanceAAMP::GetContentTypString()$/;"	f	class:PrivateInstanceAAMP
GetContext	fragmentcollector_hls.cpp	/^StreamAbstractionAAMP* TrackState::GetContext()$/;"	f	class:TrackState
GetContext	fragmentcollector_mpd.cpp	/^	StreamAbstractionAAMP* GetContext()$/;"	f	class:MediaStreamContext
GetCurProfIdxBW	StreamAbstractionAAMP.h	/^	long GetCurProfIdxBW(){$/;"	f	class:StreamAbstractionAAMP
GetCurrentAudioLanguage	main_aamp.cpp	/^char* PlayerInstanceAAMP::GetCurrentAudioLanguage(void)$/;"	f	class:PlayerInstanceAAMP
GetCurrentBandWidth	streamabstraction.cpp	/^int MediaTrack::GetCurrentBandWidth()$/;"	f	class:MediaTrack
GetCurrentDRM	main_aamp.cpp	/^DRMSystems PrivateInstanceAAMP::GetCurrentDRM(void)$/;"	f	class:PrivateInstanceAAMP
GetCurrentDRM	main_aamp.cpp	/^const char* PlayerInstanceAAMP::GetCurrentDRM(void)$/;"	f	class:PlayerInstanceAAMP
GetCurrentlyAvailableBandwidth	main_aamp.cpp	/^long PrivateInstanceAAMP::GetCurrentlyAvailableBandwidth(void)$/;"	f	class:PrivateInstanceAAMP
GetDeferTimeMs	streamabstraction.cpp	/^int MediaTrack::GetDeferTimeMs(long maxTimeSeconds)$/;"	f	class:MediaTrack
GetDesiredCodecIndex	fragmentcollector_mpd.cpp	/^static int GetDesiredCodecIndex(IAdaptationSet *adaptationSet, AudioType &selectedRepType)$/;"	f	file:
GetDesiredProfile	streamabstraction.cpp	/^int StreamAbstractionAAMP::GetDesiredProfile(bool getMidProfile)$/;"	f	class:StreamAbstractionAAMP
GetDesiredProfileBasedOnCache	streamabstraction.cpp	/^int StreamAbstractionAAMP::GetDesiredProfileBasedOnCache(void)$/;"	f	class:StreamAbstractionAAMP
GetDrmSystemID	main_aamp.cpp	/^const char * GetDrmSystemID(DRMSystems drmSystem)$/;"	f
GetDrmSystemName	main_aamp.cpp	/^const char * GetDrmSystemName(DRMSystems drmSystem)$/;"	f
GetDurationFromRepresentation	fragmentcollector_mpd.cpp	/^uint64_t PrivateStreamAbstractionMPD::GetDurationFromRepresentation()$/;"	f	class:PrivateStreamAbstractionMPD
GetDurationMs	main_aamp.cpp	/^long long PrivateInstanceAAMP::GetDurationMs()$/;"	f	class:PrivateInstanceAAMP
GetESChangeStatus	StreamAbstractionAAMP.h	/^	bool GetESChangeStatus(void){ return mESChangeStatus;}$/;"	f	class:StreamAbstractionAAMP
GetElapsedTime	streamabstraction.cpp	/^double StreamAbstractionAAMP::GetElapsedTime()$/;"	f	class:StreamAbstractionAAMP
GetFetchBuffer	streamabstraction.cpp	/^CachedFragment* MediaTrack::GetFetchBuffer(bool initialize)$/;"	f	class:MediaTrack
GetFile	main_aamp.cpp	/^bool PrivateInstanceAAMP::GetFile(const char *remoteUrl, struct GrowableBuffer *buffer, char effectiveUrl[MAX_URI_LENGTH], long * http_error, const char *range, unsigned int curlInstance, bool resetBuffer, MediaType fileType)$/;"	f	class:PrivateInstanceAAMP
GetFilePath	fragmentcollector_mpd.cpp	/^static void GetFilePath(char filePath[MAX_URI_LENGTH], const FragmentDescriptor *fragmentDescriptor, std::string media)$/;"	f	file:
GetFirstPTS	fragmentcollector_hls.cpp	/^double StreamAbstractionAAMP_HLS::GetFirstPTS()$/;"	f	class:StreamAbstractionAAMP_HLS
GetFirstPTS	fragmentcollector_mpd.cpp	/^double PrivateStreamAbstractionMPD::GetFirstPTS()$/;"	f	class:PrivateStreamAbstractionMPD
GetFirstPTS	fragmentcollector_mpd.cpp	/^double StreamAbstractionAAMP_MPD::GetFirstPTS()$/;"	f	class:StreamAbstractionAAMP_MPD
GetFirstPTS	main_aamp.cpp	/^double PrivateInstanceAAMP::GetFirstPTS()$/;"	f	class:PrivateInstanceAAMP
GetFirstSegmentStartTime	fragmentcollector_mpd.cpp	/^uint64_t GetFirstSegmentStartTime(IPeriod * period)$/;"	f
GetFormatFromFragmentExtension	fragmentcollector_hls.cpp	/^static StreamOutputFormat GetFormatFromFragmentExtension(TrackState *trackState)$/;"	f	file:
GetFragmentUriFromIndex	fragmentcollector_hls.cpp	/^char *TrackState::GetFragmentUriFromIndex()$/;"	f	class:TrackState
GetFragmentUrl	fragmentcollector_mpd.cpp	/^static void GetFragmentUrl( char fragmentUrl[MAX_URI_LENGTH], const FragmentDescriptor *fragmentDescriptor, std::string media)$/;"	f	file:
GetGstCaps	aampgstplayer.cpp	/^static GstCaps* GetGstCaps(StreamOutputFormat format)$/;"	f	file:
GetIframeTrack	streamabstraction.cpp	/^int StreamAbstractionAAMP::GetIframeTrack()$/;"	f	class:StreamAbstractionAAMP
GetLicenseReqProxy	priv_aamp.h	/^	char * GetLicenseReqProxy() { return mLicenseProxy; };$/;"	f	class:PrivateInstanceAAMP
GetManifestUrl	priv_aamp.h	/^	char *GetManifestUrl(void)$/;"	f	class:PrivateInstanceAAMP
GetMaxBWProfile	StreamAbstractionAAMP.h	/^	int GetMaxBWProfile() { return mAbrManager.getMaxBandwidthProfile(); } \/* Return the Top Profile Index*\/$/;"	f	class:StreamAbstractionAAMP
GetMediaTrack	fragmentcollector_hls.cpp	/^MediaTrack* StreamAbstractionAAMP_HLS::GetMediaTrack(TrackType type)$/;"	f	class:StreamAbstractionAAMP_HLS
GetMediaTrack	fragmentcollector_mpd.cpp	/^MediaTrack* PrivateStreamAbstractionMPD::GetMediaTrack(TrackType type)$/;"	f	class:PrivateStreamAbstractionMPD
GetMediaTrack	fragmentcollector_mpd.cpp	/^MediaTrack* StreamAbstractionAAMP_MPD::GetMediaTrack(TrackType type)$/;"	f	class:StreamAbstractionAAMP_MPD
GetMinUpdateDuration	fragmentcollector_mpd.cpp	/^	int64_t GetMinUpdateDuration() { return mMinUpdateDurationMs;}$/;"	f	class:PrivateStreamAbstractionMPD
GetMoneyTraceString	main_aamp.cpp	/^void PrivateInstanceAAMP::GetMoneyTraceString(std::string &customHeader)$/;"	f	class:PrivateInstanceAAMP
GetNextFragmentPeriodInfo	fragmentcollector_hls.cpp	/^void TrackState::GetNextFragmentPeriodInfo(int &periodIdx, double &offsetFromPeriodStart)$/;"	f	class:TrackState
GetNextFragmentUriFromPlaylist	fragmentcollector_hls.cpp	/^char *TrackState::GetNextFragmentUriFromPlaylist(bool ignoreDiscontinuity)$/;"	f	class:TrackState
GetNumberOfPeriods	fragmentcollector_hls.cpp	/^int TrackState::GetNumberOfPeriods()$/;"	f	class:TrackState
GetPeriodDuration	fragmentcollector_mpd.cpp	/^uint64_t GetPeriodDuration(IPeriod * period)$/;"	f
GetPeriodEndTime	fragmentcollector_mpd.cpp	/^uint64_t PrivateStreamAbstractionMPD::GetPeriodEndTime()$/;"	f	class:PrivateStreamAbstractionMPD
GetPeriodStartPosition	fragmentcollector_hls.cpp	/^double TrackState::GetPeriodStartPosition(int periodIdx)$/;"	f	class:TrackState
GetPersistedBandwidth	priv_aamp.h	/^	long GetPersistedBandwidth(){return mAvailableBandwidth;}$/;"	f	class:PrivateInstanceAAMP
GetPersistedProfileIndex	priv_aamp.h	/^	int  GetPersistedProfileIndex() {return mPersistedProfileIndex;}$/;"	f	class:PrivateInstanceAAMP
GetPlaybackDuration	main_aamp.cpp	/^double PlayerInstanceAAMP::GetPlaybackDuration()$/;"	f	class:PlayerInstanceAAMP
GetPlaybackPosition	main_aamp.cpp	/^double PlayerInstanceAAMP::GetPlaybackPosition()$/;"	f	class:PlayerInstanceAAMP
GetPlaybackRate	main_aamp.cpp	/^int PlayerInstanceAAMP::GetPlaybackRate(void)$/;"	f	class:PlayerInstanceAAMP
GetPlayerVideoSize	main_aamp.cpp	/^void PrivateInstanceAAMP::GetPlayerVideoSize(int &width, int &height)$/;"	f	class:PrivateInstanceAAMP
GetPlaylistURI	fragmentcollector_hls.cpp	/^const char *StreamAbstractionAAMP_HLS::GetPlaylistURI(TrackType trackType, StreamOutputFormat* format)$/;"	f	class:StreamAbstractionAAMP_HLS
GetPositionMilliseconds	aampgstplayer.cpp	/^long AAMPGstPlayer::GetPositionMilliseconds(void)$/;"	f	class:AAMPGstPlayer
GetPositionMilliseconds	main_aamp.h	/^	virtual long GetPositionMilliseconds(void){ return 0; };$/;"	f	class:StreamSink
GetPositionMs	main_aamp.cpp	/^long long PrivateInstanceAAMP::GetPositionMs()$/;"	f	class:PrivateInstanceAAMP
GetProfileCount	StreamAbstractionAAMP.h	/^	int GetProfileCount() {$/;"	f	class:StreamAbstractionAAMP
GetProfileCount	fragmentcollector_mpd.cpp	/^int PrivateStreamAbstractionMPD::GetProfileCount()$/;"	f	class:PrivateStreamAbstractionMPD
GetProfilerBucketForMedia	priv_aamp.h	/^	ProfilerBucketType GetProfilerBucketForMedia(MediaType mediaType, bool isInitializationSegment)$/;"	f	class:PrivateInstanceAAMP
GetSeekBase	main_aamp.cpp	/^double PrivateInstanceAAMP::GetSeekBase(void)$/;"	f	class:PrivateInstanceAAMP
GetSeqenceNumberfromURL	main_aamp.cpp	/^long long PrivateInstanceAAMP::GetSeqenceNumberfromURL(const char *fragmentUrl)$/;"	f	class:PrivateInstanceAAMP
GetState	main_aamp.cpp	/^PrivAAMPState PlayerInstanceAAMP::GetState(void)$/;"	f	class:PlayerInstanceAAMP
GetState	main_aamp.cpp	/^void PrivateInstanceAAMP::GetState(PrivAAMPState& state)$/;"	f	class:PrivateInstanceAAMP
GetStreamFormat	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::GetStreamFormat(StreamOutputFormat &primaryOutputFormat, StreamOutputFormat &audioOutputFormat)$/;"	f	class:StreamAbstractionAAMP_HLS
GetStreamFormat	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::GetStreamFormat(StreamOutputFormat &primaryOutputFormat, StreamOutputFormat &audioOutputFormat)$/;"	f	class:PrivateStreamAbstractionMPD
GetStreamFormat	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::GetStreamFormat(StreamOutputFormat &primaryOutputFormat, StreamOutputFormat &audioOutputFormat)$/;"	f	class:StreamAbstractionAAMP_MPD
GetStreamInfo	fragmentcollector_hls.h	/^	StreamInfo* GetStreamInfo(int idx){ return &streamInfo[idx];}$/;"	f	class:StreamAbstractionAAMP_HLS
GetStreamInfo	fragmentcollector_mpd.cpp	/^StreamInfo* PrivateStreamAbstractionMPD::GetStreamInfo(int idx)$/;"	f	class:PrivateStreamAbstractionMPD
GetStreamInfo	fragmentcollector_mpd.cpp	/^StreamInfo* StreamAbstractionAAMP_MPD::GetStreamInfo(int idx)$/;"	f	class:StreamAbstractionAAMP_MPD
GetStreamPosition	fragmentcollector_hls.h	/^	double GetStreamPosition() { return seekPosition; }$/;"	f	class:StreamAbstractionAAMP_HLS
GetStreamPosition	fragmentcollector_mpd.cpp	/^	double GetStreamPosition() { return seekPosition; }$/;"	f	class:PrivateStreamAbstractionMPD
GetStreamPosition	fragmentcollector_mpd.cpp	/^double StreamAbstractionAAMP_MPD::GetStreamPosition()$/;"	f	class:StreamAbstractionAAMP_MPD
GetTR181AAMPConfig	main_aamp.cpp	/^char *  GetTR181AAMPConfig(const char * paramName, size_t & iConfigLen)$/;"	f
GetTotalFetchedDuration	StreamAbstractionAAMP.h	/^	double GetTotalFetchedDuration() { return totalFetchedDuration; };$/;"	f	class:MediaTrack
GetTotalFragmentsFetched	StreamAbstractionAAMP.h	/^	int GetTotalFragmentsFetched(){ return totalFragmentsDownloaded; }$/;"	f	class:MediaTrack
GetTotalInjectedDuration	StreamAbstractionAAMP.h	/^	double GetTotalInjectedDuration() { return totalInjectedDuration; };$/;"	f	class:MediaTrack
GetTunedManifestUrl	main_aamp.cpp	/^const char* PrivateInstanceAAMP::GetTunedManifestUrl()$/;"	f	class:PrivateInstanceAAMP
GetVideoBitrate	main_aamp.cpp	/^long PlayerInstanceAAMP::GetVideoBitrate(void)$/;"	f	class:PlayerInstanceAAMP
GetVideoBitrate	main_aamp.cpp	/^long PrivateInstanceAAMP::GetVideoBitrate()$/;"	f	class:PrivateInstanceAAMP
GetVideoBitrate	streamabstraction.cpp	/^long StreamAbstractionAAMP::GetVideoBitrate(void)$/;"	f	class:StreamAbstractionAAMP
GetVideoBitrates	fragmentcollector_hls.cpp	/^std::vector<long> StreamAbstractionAAMP_HLS::GetVideoBitrates(void)$/;"	f	class:StreamAbstractionAAMP_HLS
GetVideoBitrates	fragmentcollector_mpd.cpp	/^std::vector<long> PrivateStreamAbstractionMPD::GetVideoBitrates(void)$/;"	f	class:PrivateStreamAbstractionMPD
GetVideoBitrates	fragmentcollector_mpd.cpp	/^std::vector<long> StreamAbstractionAAMP_MPD::GetVideoBitrates(void)$/;"	f	class:StreamAbstractionAAMP_MPD
GetVideoBitrates	main_aamp.cpp	/^std::vector<long> PlayerInstanceAAMP::GetVideoBitrates(void)$/;"	f	class:PlayerInstanceAAMP
GetVideoSize	aampgstplayer.cpp	/^void AAMPGstPlayer::GetVideoSize(int &width, int &height)$/;"	f	class:AAMPGstPlayer
GetVideoSize	main_aamp.h	/^	virtual void GetVideoSize(int &w, int &h){};$/;"	f	class:StreamSink
GlobalConfigAAMP	priv_aamp.h	/^	GlobalConfigAAMP() :defaultBitrate(DEFAULT_INIT_BITRATE), defaultBitrate4K(DEFAULT_INIT_BITRATE_4K), bEnableABR(true), SAP(false), noFog(false), mapMPD(0), fogSupportsDash(true),abrCacheLife(DEFAULT_ABR_CACHE_LIFE),abrCacheLength(DEFAULT_ABR_CACHE_LENGTH),maxCachedFragmentsPerTrack(DEFAULT_CACHED_FRAGMENTS_PER_TRACK),$/;"	f	class:GlobalConfigAAMP
GlobalConfigAAMP	priv_aamp.h	/^class GlobalConfigAAMP$/;"	c
GrowableBuffer	priv_aamp.h	/^struct GrowableBuffer$/;"	s
GstPlayFlags	aampgstplayer.cpp	/^} GstPlayFlags;$/;"	t	typeref:enum:__anon3	file:
GstPluginNamePR	aampgstplayer.cpp	/^static const char* GstPluginNamePR = "aampplayreadydecryptor";$/;"	v	file:
GstPluginNameWV	aampgstplayer.cpp	/^static const char* GstPluginNameWV = "aampwidevinedecryptor";$/;"	v	file:
H264PPS	tsprocessor.h	/^      } H264PPS;$/;"	t	class:TSProcessor	typeref:struct:TSProcessor::_H264PPS
H264SPS	tsprocessor.h	/^      } H264SPS;$/;"	t	class:TSProcessor	typeref:struct:TSProcessor::_H264SPS
HARVEST_BASE_PATH	fragmentcollector_mpd.cpp	111;"	d	file:
HARVEST_BASE_PATH	fragmentcollector_mpd.cpp	113;"	d	file:
HEADER_SIZE	tsprocessor.cpp	2402;"	d	file:
HarvestFile	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::HarvestFile(const char * url, GrowableBuffer* buffer, bool isFragment, const char* prefix)$/;"	f	class:StreamAbstractionAAMP_HLS
HarvestFragments	main_aamp.cpp	/^bool PrivateInstanceAAMP::HarvestFragments(bool modifyCount)$/;"	f	class:PrivateInstanceAAMP
HasDiscontinuityAroundPosition	fragmentcollector_hls.cpp	/^bool TrackState::HasDiscontinuityAroundPosition(double position, bool useStartTime, double &diffBetweenDiscontinuities, double playPosition)$/;"	f	class:TrackState
HeaderFetchParams	fragmentcollector_mpd.cpp	/^struct HeaderFetchParams$/;"	s	file:
HlsStreamInfo	fragmentcollector_hls.h	/^typedef struct HlsStreamInfo: public StreamInfo$/;"	s
HlsStreamInfo	fragmentcollector_hls.h	/^} HlsStreamInfo;$/;"	t	typeref:struct:HlsStreamInfo
HttpHeaderType	priv_aamp.h	/^enum HttpHeaderType$/;"	g
IDX_BUFF_SIZE	tsprocessor.cpp	108;"	d	file:
INDEX	tsprocessor.cpp	2403;"	d	file:
INFO	tsprocessor.cpp	63;"	d	file:
INFO	tsprocessor.cpp	65;"	d	file:
INPUT_GAIN_DB_MUTE	aampgstplayer.cpp	86;"	d	file:
INPUT_GAIN_DB_UNMUTE	aampgstplayer.cpp	87;"	d	file:
IS_PES_PACKET_START	tsprocessor.cpp	123;"	d	file:
I_FRAME	tsprocessor.cpp	103;"	d	file:
IdleCallback	aampgstplayer.cpp	/^static gboolean IdleCallback(gpointer user_data)$/;"	f	file:
IdleCallbackOnEOS	aampgstplayer.cpp	/^static gboolean IdleCallbackOnEOS(gpointer user_data)$/;"	f	file:
IdleCallbackOnFirstFrame	aampgstplayer.cpp	/^static gboolean IdleCallbackOnFirstFrame(gpointer user_data)$/;"	f	file:
IdleTask	priv_aamp.h	/^typedef int(*IdleTask)(void* arg);$/;"	t
IndexNode	fragmentcollector_hls.h	/^struct IndexNode$/;"	s
IndexPlaylist	fragmentcollector_hls.cpp	/^void TrackState::IndexPlaylist()$/;"	f	class:TrackState
Init	fragmentcollector_hls.cpp	/^AAMPStatusType StreamAbstractionAAMP_HLS::Init(TuneType tuneType)$/;"	f	class:StreamAbstractionAAMP_HLS
Init	fragmentcollector_mpd.cpp	/^AAMPStatusType PrivateStreamAbstractionMPD::Init(TuneType tuneType)$/;"	f	class:PrivateStreamAbstractionMPD
Init	fragmentcollector_mpd.cpp	/^AAMPStatusType StreamAbstractionAAMP_MPD::Init(TuneType tuneType)$/;"	f	class:StreamAbstractionAAMP_MPD
InitializeAAMPGstreamerPlugins	aampgstplayer.cpp	/^void AAMPGstPlayer::InitializeAAMPGstreamerPlugins()$/;"	f	class:AAMPGstPlayer
InitializeSource	aampgstplayer.cpp	/^static void InitializeSource( AAMPGstPlayer *_this,GObject *source, MediaType mediaType = eMEDIATYPE_VIDEO )$/;"	f	file:
InjectFragment	streamabstraction.cpp	/^bool MediaTrack::InjectFragment()$/;"	f	class:MediaTrack
InjectFragmentInternal	fragmentcollector_hls.cpp	/^void TrackState::InjectFragmentInternal(CachedFragment* cachedFragment, bool &fragmentDiscarded)$/;"	f	class:TrackState
InjectFragmentInternal	fragmentcollector_mpd.cpp	/^	void InjectFragmentInternal(CachedFragment* cachedFragment, bool &fragmentDiscarded)$/;"	f	class:MediaStreamContext
InsertAd	main_aamp.cpp	/^void PlayerInstanceAAMP::InsertAd(const char *url, double positionSeconds)$/;"	f	class:PlayerInstanceAAMP
InsertAd	main_aamp.cpp	/^void PrivateInstanceAAMP::InsertAd(const char *url, double positionSeconds)$/;"	f	class:PrivateInstanceAAMP
InsertToPlaylistCache	main_aamp.cpp	/^void PrivateInstanceAAMP::InsertToPlaylistCache(const std::string url, const GrowableBuffer* buffer, const char* effectiveUrl)$/;"	f	class:PrivateInstanceAAMP
InterruptableMsSleep	main_aamp.cpp	/^void PrivateInstanceAAMP::InterruptableMsSleep(int timeInMs)$/;"	f	class:PrivateInstanceAAMP
IsAudioLanguageSupported	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsAudioLanguageSupported (const char *checkLanguage)$/;"	f	class:PrivateInstanceAAMP
IsCDVRContent	priv_aamp.h	/^	bool IsCDVRContent() { return (mContentType==ContentType_CDVR || mIscDVR);}$/;"	f	class:PrivateInstanceAAMP
IsCacheEmpty	aampgstplayer.cpp	/^bool AAMPGstPlayer::IsCacheEmpty(MediaType mediaType)$/;"	f	class:AAMPGstPlayer
IsCacheEmpty	main_aamp.h	/^	virtual bool IsCacheEmpty(MediaType mediaType){ return true; };$/;"	f	class:StreamSink
IsCompatibleMimeType	fragmentcollector_mpd.cpp	/^static bool IsCompatibleMimeType(std::string mimeType, MediaType mediaType)$/;"	f	file:
IsContentType	fragmentcollector_mpd.cpp	/^static bool IsContentType(IAdaptationSet *adaptationSet, MediaType mediaType )$/;"	f	file:
IsDiscontinuityProcessPending	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsDiscontinuityProcessPending()$/;"	f	class:PrivateInstanceAAMP
IsDiscontinuityProcessed	StreamAbstractionAAMP.h	/^	bool IsDiscontinuityProcessed() { return discontinuityProcessed; }$/;"	f	class:MediaTrack
IsFragmentBufferingRequired	StreamAbstractionAAMP.h	/^	bool IsFragmentBufferingRequired() { return false; }$/;"	f	class:StreamAbstractionAAMP
IsFragmentBufferingRequired	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsFragmentBufferingRequired()$/;"	f	class:PrivateInstanceAAMP
IsIframeTrack	fragmentcollector_mpd.cpp	/^static bool IsIframeTrack(IAdaptationSet *adaptationSet)$/;"	f	file:
IsInProgressCDVR	priv_aamp.h	/^	bool IsInProgressCDVR() {return (IsLive() && IsCDVRContent());}$/;"	f	class:PrivateInstanceAAMP
IsLive	main_aamp.cpp	/^bool PlayerInstanceAAMP::IsLive()$/;"	f	class:PlayerInstanceAAMP
IsLive	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsLive()$/;"	f	class:PrivateInstanceAAMP
IsLocalPlayback	priv_aamp.h	/^	bool IsLocalPlayback() { return mIsLocalPlayback; }$/;"	f	class:PrivateInstanceAAMP
IsSinkCacheEmpty	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsSinkCacheEmpty(MediaType mediaType)$/;"	f	class:PrivateInstanceAAMP
IsStreamerAtLivePoint	StreamAbstractionAAMP.h	/^	bool IsStreamerAtLivePoint() { return mIsAtLivePoint; }$/;"	f	class:StreamAbstractionAAMP
IsStreamerStalled	StreamAbstractionAAMP.h	/^	bool IsStreamerStalled(void) { return mIsPlaybackStalled; }$/;"	f	class:StreamAbstractionAAMP
IsTSBSupported	priv_aamp.h	/^	bool IsTSBSupported() { return mTSBEnabled;}$/;"	f	class:PrivateInstanceAAMP
IsTuneCompleted	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsTuneCompleted()$/;"	f	class:PrivateInstanceAAMP
IsTuneTypeNew	priv_aamp.h	/^	bool IsTuneTypeNew; \/* Flag for the eTUNETYPE_NEW_NORMAL *\/$/;"	m	class:PrivateInstanceAAMP
IsVodOrCdvrAsset	main_aamp.cpp	/^bool PrivateInstanceAAMP::IsVodOrCdvrAsset()$/;"	f	class:PrivateInstanceAAMP
LOCAL_HOST_IP	main_aamp.cpp	163;"	d	file:
LOG_WARNINGS_AND_ERRORS	tsprocessor.cpp	69;"	d	file:
LastVideoFragParsedTimeMS	streamabstraction.cpp	/^double StreamAbstractionAAMP::LastVideoFragParsedTimeMS(void)$/;"	f	class:StreamAbstractionAAMP
LazilyLoadConfigIfNeeded	main_aamp.cpp	/^void PrivateInstanceAAMP::LazilyLoadConfigIfNeeded(void)$/;"	f	class:PrivateInstanceAAMP
ListenerData	priv_aamp.h	/^struct ListenerData {$/;"	s
LoadFragment	main_aamp.cpp	/^bool PrivateInstanceAAMP::LoadFragment(ProfilerBucketType bucketType, const char *fragmentUrl, struct GrowableBuffer *fragment, unsigned int curlInstance, const char *range, MediaType fileType, long * http_code)$/;"	f	class:PrivateInstanceAAMP
LoadFragment	main_aamp.cpp	/^char *PrivateInstanceAAMP::LoadFragment(ProfilerBucketType bucketType, const char *fragmentUrl, size_t *len, unsigned int curlInstance, const char *range, MediaType fileType)$/;"	f	class:PrivateInstanceAAMP
LoadJS	main_aamp.cpp	/^void PlayerInstanceAAMP::LoadJS(void* context)$/;"	f	class:PlayerInstanceAAMP
LogABRInfo	aamplogging.cpp	/^void AampLogManager::LogABRInfo(AAMPAbrInfo *pstAbrInfo)$/;"	f	class:AampLogManager
LogDRMError	aamplogging.cpp	/^void AampLogManager::LogDRMError(int major, int minor)$/;"	f	class:AampLogManager
LogDrmDecryptBegin	main_aamp.cpp	/^void PrivateInstanceAAMP::LogDrmDecryptBegin(ProfilerBucketType bucketType)$/;"	f	class:PrivateInstanceAAMP
LogDrmDecryptEnd	main_aamp.cpp	/^void PrivateInstanceAAMP::LogDrmDecryptEnd(ProfilerBucketType bucketType)$/;"	f	class:PrivateInstanceAAMP
LogDrmInitComplete	main_aamp.cpp	/^void PrivateInstanceAAMP::LogDrmInitComplete(void)$/;"	f	class:PrivateInstanceAAMP
LogFirstFrame	main_aamp.cpp	/^void PrivateInstanceAAMP::LogFirstFrame(void)$/;"	f	class:PrivateInstanceAAMP
LogNetworkError	aamplogging.cpp	/^void AampLogManager::LogNetworkError(const char* url, AAMPNetworkErrorType errorType, int errorCode)$/;"	f	class:AampLogManager
LogNetworkLatency	aamplogging.cpp	/^void AampLogManager::LogNetworkLatency(const char* url, int downloadTime, int downloadThresholdTimeoutMs)$/;"	f	class:AampLogManager
LogTuneComplete	main_aamp.cpp	/^void PrivateInstanceAAMP::LogTuneComplete(void)$/;"	f	class:PrivateInstanceAAMP
MAC_STRING_LEN	streamabstraction.cpp	48;"	d	file:
MAINAAMP_H	main_aamp.h	61;"	d
MANIFEST_TEMP_DATA_LENGTH	priv_aamp.h	109;"	d
MAX_ANOMALY_BUFF_SIZE	main_aamp.h	210;"	d
MAX_BITRATE_COUNT	main_aamp.h	207;"	d
MAX_BYTES_TO_SEND	aampgstplayer.cpp	1700;"	d	file:
MAX_CURL_INSTANCE_COUNT	priv_aamp.h	63;"	d
MAX_DEBUG_LOG_BUFF_SIZE	aamplogging.cpp	45;"	d	file:
MAX_DELAY_BETWEEN_MPD_UPDATE_MS	fragmentcollector_mpd.cpp	69;"	d	file:
MAX_DELAY_BETWEEN_PLAYLIST_UPDATE_MS	fragmentcollector_hls.cpp	67;"	d	file:
MAX_DELAY_BETWEEN_PLAYLIST_UPDATE_MS	fragmentcollector_hls.h	59;"	d
MAX_DESCRIPTOR	tsprocessor.cpp	101;"	d	file:
MAX_ERROR_DESCRIPTION_LENGTH	main_aamp.h	206;"	d
MAX_FIRST_PTS_OFFSET	tsprocessor.cpp	130;"	d	file:
MAX_ID_SIZE	fragmentcollector_mpd.cpp	63;"	d	file:
MAX_LANGUAGE_COUNT	main_aamp.h	204;"	d
MAX_LANGUAGE_TAG_LENGTH	main_aamp.h	205;"	d
MAX_LICENSE_ACQ_WAIT_TIME	fragmentcollector_hls.cpp	70;"	d	file:
MAX_MANIFEST_DOWNLOAD_RETRY	fragmentcollector_hls.cpp	66;"	d	file:
MAX_MANIFEST_DOWNLOAD_RETRY	fragmentcollector_hls.h	58;"	d
MAX_OVERRIDE	main_aamp.cpp	2577;"	d	file:
MAX_PACKET_SIZE	tsprocessor.cpp	88;"	d	file:
MAX_PIDS	tsprocessor.h	39;"	d
MAX_PLAYLIST_REFRESH_FOR_DISCONTINUITY_CHECK_EVENT	fragmentcollector_hls.cpp	74;"	d	file:
MAX_PLAYLIST_REFRESH_FOR_DISCONTINUITY_CHECK_LIVE	fragmentcollector_hls.cpp	75;"	d	file:
MAX_PMT_SECTION_SIZE	tsprocessor.cpp	94;"	d	file:
MAX_PROFILE	fragmentcollector_hls.h	50;"	d
MAX_PTS	tsprocessor.cpp	98;"	d	file:
MAX_PTS_ERRORS_THRESHOLD	priv_aamp.h	107;"	d
MAX_SCAN_REMAINDER_SIZE	tsprocessor.h	82;"	d
MAX_SCAN_REMAINDER_SIZE	tsprocessor.h	84;"	d
MAX_SEG_DOWNLOAD_FAIL_COUNT	priv_aamp.h	88;"	d
MAX_SEG_DRM_DECRYPT_FAIL_COUNT	priv_aamp.h	89;"	d
MAX_SEG_INJECT_FAIL_COUNT	priv_aamp.h	90;"	d
MAX_SEQ_NUMBER_DIFF_FOR_SEQ_NUM_BASED_SYNC	fragmentcollector_hls.cpp	72;"	d	file:
MAX_SEQ_NUMBER_LAG_COUNT	fragmentcollector_hls.cpp	71;"	d	file:
MAX_SUPPORTED_LATENCY_LOGGING_TYPES	priv_aamp.h	248;"	d
MAX_SUPPORTED_SPEED_COUNT	main_aamp.h	208;"	d
MAX_URI_LENGTH	priv_aamp.h	60;"	d
MBAddrIncCode	tsprocessor.cpp	/^struct MBAddrIncCode$/;"	s	file:
MIN_DELAY_BETWEEN_MPD_UPDATE_MS	fragmentcollector_mpd.cpp	70;"	d	file:
MIN_DELAY_BETWEEN_PLAYLIST_UPDATE_MS	fragmentcollector_hls.cpp	68;"	d	file:
MIN_DELAY_BETWEEN_PLAYLIST_UPDATE_MS	fragmentcollector_hls.h	60;"	d
MediaInfo	fragmentcollector_hls.h	/^typedef struct MediaInfo$/;"	s
MediaInfo	fragmentcollector_hls.h	/^} MediaInfo;$/;"	t	typeref:struct:MediaInfo
MediaStreamContext	fragmentcollector_mpd.cpp	/^	MediaStreamContext(TrackType type, StreamAbstractionAAMP_MPD* context, PrivateInstanceAAMP* aamp, const char* name) :$/;"	f	class:MediaStreamContext
MediaStreamContext	fragmentcollector_mpd.cpp	/^class MediaStreamContext : public MediaTrack$/;"	c	file:
MediaTrack	StreamAbstractionAAMP.h	/^class MediaTrack$/;"	c
MediaTrack	streamabstraction.cpp	/^MediaTrack::MediaTrack(TrackType type, PrivateInstanceAAMP* aamp, const char* name) :$/;"	f	class:MediaTrack
MediaType	main_aamp.h	/^enum MediaType$/;"	g
MediaTypeString	main_aamp.cpp	/^const char* PrivateInstanceAAMP::MediaTypeString(MediaType fileType)$/;"	f	class:PrivateInstanceAAMP
MonitorBufferHealth	streamabstraction.cpp	/^void MediaTrack::MonitorBufferHealth()$/;"	f	class:MediaTrack
NOTICE	tsprocessor.cpp	73;"	d	file:
NOTICE	tsprocessor.cpp	78;"	d	file:
NOW_STEADY_TS_MS	priv_aamp.h	103;"	d
NOW_SYSTEM_TS_MS	priv_aamp.h	102;"	d
NotifyBitRateChangeEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyBitRateChangeEvent(int bitrate ,const char *description ,int width ,int height, bool GetBWIndex)$/;"	f	class:PrivateInstanceAAMP
NotifyBitRateUpdate	streamabstraction.cpp	/^void StreamAbstractionAAMP::NotifyBitRateUpdate(int profileIndex)$/;"	f	class:StreamAbstractionAAMP
NotifyEOS	aampgstplayer.cpp	/^void AAMPGstPlayer::NotifyEOS()$/;"	f	class:AAMPGstPlayer
NotifyEOSReached	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyEOSReached()$/;"	f	class:PrivateInstanceAAMP
NotifyFirstBufferProcessed	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyFirstBufferProcessed()$/;"	f	class:PrivateInstanceAAMP
NotifyFirstFragmentDecrypted	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyFirstFragmentDecrypted()$/;"	f	class:PrivateInstanceAAMP
NotifyFirstFragmentInjected	streamabstraction.cpp	/^void StreamAbstractionAAMP::NotifyFirstFragmentInjected()$/;"	f	class:StreamAbstractionAAMP
NotifyFirstFrame	aampgstplayer.cpp	/^void AAMPGstPlayer::NotifyFirstFrame(MediaType type)$/;"	f	class:AAMPGstPlayer
NotifyFirstFrameReceived	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyFirstFrameReceived()$/;"	f	class:PrivateInstanceAAMP
NotifyFragmentCachingComplete	aampgstplayer.cpp	/^void AAMPGstPlayer::NotifyFragmentCachingComplete()$/;"	f	class:AAMPGstPlayer
NotifyFragmentCachingComplete	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyFragmentCachingComplete()$/;"	f	class:PrivateInstanceAAMP
NotifyFragmentCachingComplete	main_aamp.h	/^	virtual void NotifyFragmentCachingComplete(){};$/;"	f	class:StreamSink
NotifyOnEnteringLive	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifyOnEnteringLive()$/;"	f	class:PrivateInstanceAAMP
NotifyPlaybackPaused	streamabstraction.cpp	/^void StreamAbstractionAAMP::NotifyPlaybackPaused(bool paused)$/;"	f	class:StreamAbstractionAAMP
NotifySpeedChanged	main_aamp.cpp	/^void PrivateInstanceAAMP::NotifySpeedChanged(int rate)$/;"	f	class:PrivateInstanceAAMP
Number	fragmentcollector_mpd.cpp	/^	uint64_t Number;$/;"	m	struct:FragmentDescriptor	file:
PACKET_SIZE	tsprocessor.cpp	87;"	d	file:
PATPMT_MAX_SIZE	tsprocessor.cpp	95;"	d	file:
PAYLOAD_UNIT_START	tsprocessor.cpp	121;"	d	file:
PES_HEADER_LENGTH	tsprocessor.cpp	125;"	d	file:
PES_MIN_DATA	tsprocessor.cpp	127;"	d	file:
PES_OPTIONAL_HEADER_LENGTH	tsprocessor.cpp	126;"	d	file:
PES_OPTIONAL_HEADER_PRESENT	tsprocessor.cpp	124;"	d	file:
PES_PAYLOAD_LENGTH	tsprocessor.cpp	129;"	d	file:
PES_STATE_GETTING_ES	tsprocessor.cpp	119;"	d	file:
PES_STATE_GETTING_HEADER	tsprocessor.cpp	117;"	d	file:
PES_STATE_GETTING_HEADER_EXTENSION	tsprocessor.cpp	118;"	d	file:
PES_STATE_WAITING_FOR_HEADER	tsprocessor.cpp	116;"	d	file:
PLAYLIST_TIME_DIFF_THRESHOLD_SECONDS	fragmentcollector_hls.cpp	65;"	d	file:
PLAYLIST_TIME_DIFF_THRESHOLD_SECONDS	fragmentcollector_hls.h	57;"	d
PLAYREADY_SYSTEM_ID	fragmentcollector_mpd.cpp	65;"	d	file:
PLAY_BUFFER_AUDIO_MAX_PACKETS	tsprocessor.cpp	863;"	d	file:
PLAY_BUFFER_CTX_OFFSET	tsprocessor.cpp	867;"	d	file:
PLAY_BUFFER_MAX_PACKETS	tsprocessor.cpp	864;"	d	file:
PLAY_BUFFER_SIGNATURE	tsprocessor.cpp	868;"	d	file:
PLAY_BUFFER_SIZE	tsprocessor.cpp	865;"	d	file:
POOL_BUFFER_ALIGNMENT	tsprocessor.cpp	866;"	d	file:
PRIVAAMP_H	priv_aamp.h	26;"	d
PROFILE_BUCKET_DECRYPT_AUDIO	priv_aamp.h	/^	PROFILE_BUCKET_DECRYPT_AUDIO,       \/**< Audio decryption bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_DECRYPT_VIDEO	priv_aamp.h	/^	PROFILE_BUCKET_DECRYPT_VIDEO,       \/**< Video decryption bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_FIRST_BUFFER	priv_aamp.h	/^	PROFILE_BUCKET_FIRST_BUFFER,        \/**< First buffer to gstreamer bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_FIRST_FRAME	priv_aamp.h	/^	PROFILE_BUCKET_FIRST_FRAME,         \/**< First frame displaye bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_FRAGMENT_AUDIO	priv_aamp.h	/^	PROFILE_BUCKET_FRAGMENT_AUDIO,      \/**< Audio fragment download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_FRAGMENT_VIDEO	priv_aamp.h	/^	PROFILE_BUCKET_FRAGMENT_VIDEO,      \/**< Video fragment download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_INIT_AUDIO	priv_aamp.h	/^	PROFILE_BUCKET_INIT_AUDIO,          \/**< Audio init fragment download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_INIT_VIDEO	priv_aamp.h	/^	PROFILE_BUCKET_INIT_VIDEO,          \/**< Video init fragment download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_LA_NETWORK	priv_aamp.h	/^	PROFILE_BUCKET_LA_NETWORK,          \/**< License acquisition network operation bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_LA_POSTPROC	priv_aamp.h	/^	PROFILE_BUCKET_LA_POSTPROC,         \/**< License acquisition post-processing bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_LA_PREPROC	priv_aamp.h	/^	PROFILE_BUCKET_LA_PREPROC,          \/**< License acquisition pre-processing bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_LA_TOTAL	priv_aamp.h	/^	PROFILE_BUCKET_LA_TOTAL,            \/**< License acquisition total bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_MANIFEST	priv_aamp.h	/^	PROFILE_BUCKET_MANIFEST,            \/**< Manifest download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_PLAYLIST_AUDIO	priv_aamp.h	/^	PROFILE_BUCKET_PLAYLIST_AUDIO,      \/**< Audio playlist download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_PLAYLIST_VIDEO	priv_aamp.h	/^	PROFILE_BUCKET_PLAYLIST_VIDEO,      \/**< Video playlist download bucket*\/$/;"	e	enum:__anon23
PROFILE_BUCKET_TYPE_COUNT	priv_aamp.h	/^	PROFILE_BUCKET_TYPE_COUNT           \/**< Bucket count*\/$/;"	e	enum:__anon23
P_FRAME	tsprocessor.cpp	104;"	d	file:
ParseAttrList	fragmentcollector_hls.cpp	/^static void ParseAttrList(char *attrName, void(*cb)(char *attrName, char *delim, char *fin, void *context), void *context)$/;"	f	file:
ParseContentUrl	aamplogging.cpp	/^void AampLogManager::ParseContentUrl(const char* url, std::string& contentType, std::string& location, std::string& symptom)$/;"	f	class:AampLogManager
ParseISO8601Duration	fragmentcollector_mpd.cpp	/^static void ParseISO8601Duration(const char *ptr, uint64_t &durationMs)$/;"	f	file:
ParseKeyAttributeCallback	fragmentcollector_hls.cpp	/^static void ParseKeyAttributeCallback(char *attrName, char *delimEqual, char *fin, void* arg)$/;"	f	file:
ParseMainManifest	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::ParseMainManifest(char *ptr)$/;"	f	class:StreamAbstractionAAMP_HLS
ParseMediaAttributeCallback	fragmentcollector_hls.cpp	/^static void ParseMediaAttributeCallback(char *attrName, char *delimEqual, char *fin, void *arg)$/;"	f	file:
ParseSegmentIndexBox	fragmentcollector_mpd.cpp	/^static bool ParseSegmentIndexBox( const char *start, size_t size, int segmentIndex, unsigned int *referenced_size, float *referenced_duration )$/;"	f	file:
ParseStreamInfCallback	fragmentcollector_hls.cpp	/^static void ParseStreamInfCallback(char *attrName, char *delimEqual, char *fin, void* arg)$/;"	f	file:
ParseTimeFromProgramDateTime	fragmentcollector_hls.cpp	/^static bool ParseTimeFromProgramDateTime(const char* ptr, struct timeval &programDateTimeVal )$/;"	f	file:
ParseXmlNS	fragmentcollector_mpd.cpp	/^static void ParseXmlNS(const std::string& fullName, std::string& ns, std::string& name)$/;"	f	file:
Pause	aampgstplayer.cpp	/^void AAMPGstPlayer::Pause( bool pause )$/;"	f	class:AAMPGstPlayer
Pause	main_aamp.h	/^	virtual void Pause(bool pause){}$/;"	f	class:StreamSink
PauseAndFlush	aampgstplayer.cpp	/^void AAMPGstPlayer::PauseAndFlush(bool playAfterFlush)$/;"	f	class:AAMPGstPlayer
PeriodInfo	fragmentcollector_mpd.cpp	/^	PeriodInfo() {$/;"	f	struct:PeriodInfo
PeriodInfo	fragmentcollector_mpd.cpp	/^struct PeriodInfo {$/;"	s	file:
PlayMode	tsprocessor.h	/^} PlayMode;$/;"	t	typeref:enum:_PlayMode
PlayMode_normal	tsprocessor.h	/^	PlayMode_normal,$/;"	e	enum:_PlayMode
PlayMode_retimestamp_IPB	tsprocessor.h	/^	PlayMode_retimestamp_IPB,$/;"	e	enum:_PlayMode
PlayMode_retimestamp_IandP	tsprocessor.h	/^	PlayMode_retimestamp_IandP,$/;"	e	enum:_PlayMode
PlayMode_retimestamp_Ionly	tsprocessor.h	/^	PlayMode_retimestamp_Ionly,$/;"	e	enum:_PlayMode
PlayMode_reverse_GOP	tsprocessor.h	/^	PlayMode_reverse_GOP,$/;"	e	enum:_PlayMode
PlaybackErrorType	priv_aamp.h	/^enum PlaybackErrorType$/;"	g
PlayerInstanceAAMP	main_aamp.cpp	/^PlayerInstanceAAMP::PlayerInstanceAAMP(StreamSink* streamSink)$/;"	f	class:PlayerInstanceAAMP
PlayerInstanceAAMP	main_aamp.h	/^class PlayerInstanceAAMP$/;"	c
PlaylistType	StreamAbstractionAAMP.h	/^} PlaylistType;$/;"	t	typeref:enum:__anon2
PrivAAMPState	main_aamp.h	/^} PrivAAMPState;$/;"	t	typeref:enum:__anon8
PrivateInstanceAAMP	main_aamp.cpp	/^PrivateInstanceAAMP::PrivateInstanceAAMP()$/;"	f	class:PrivateInstanceAAMP
PrivateInstanceAAMP	priv_aamp.h	/^class PrivateInstanceAAMP$/;"	c
PrivateInstanceAAMP_ProcessDiscontinuity	main_aamp.cpp	/^static gboolean PrivateInstanceAAMP_ProcessDiscontinuity(gpointer ptr)$/;"	f	file:
PrivateInstanceAAMP_Resume	main_aamp.cpp	/^static gboolean PrivateInstanceAAMP_Resume(gpointer ptr)$/;"	f	file:
PrivateInstanceAAMP_Retune	main_aamp.cpp	/^static gboolean PrivateInstanceAAMP_Retune(gpointer ptr)$/;"	f	file:
PrivateStreamAbstractionMPD	fragmentcollector_mpd.cpp	/^PrivateStreamAbstractionMPD::PrivateStreamAbstractionMPD( StreamAbstractionAAMP_MPD* context, PrivateInstanceAAMP *aamp,double seekpos, float rate)$/;"	f	class:PrivateStreamAbstractionMPD
PrivateStreamAbstractionMPD	fragmentcollector_mpd.cpp	/^class PrivateStreamAbstractionMPD$/;"	c	file:
ProcessConfigEntry	main_aamp.cpp	/^static void ProcessConfigEntry(char *cfg)$/;"	f	file:
ProcessContentProtection	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessContentProtection(IAdaptationSet * adaptationSet,MediaType mediaType)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessDrmMetadata	fragmentcollector_hls.cpp	/^void TrackState::ProcessDrmMetadata(bool acquireCurrentLicenseOnly)$/;"	f	class:TrackState
ProcessNode	fragmentcollector_mpd.cpp	/^static Node* ProcessNode(xmlTextReaderPtr *reader, char *url)$/;"	f	file:
ProcessPendingDiscontinuity	main_aamp.cpp	/^void PrivateInstanceAAMP::ProcessPendingDiscontinuity()$/;"	f	class:PrivateInstanceAAMP
ProcessPeriodAssetIdentifier	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessPeriodAssetIdentifier(Node* node, uint64_t startMS, uint64_t durationMS, std::string& AssetID, std::string& ProviderID)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessPeriodSupplementalProperty	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessPeriodSupplementalProperty(Node* node, std::string& AdID, uint64_t startMS, uint64_t durationMS)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessStreamRestriction	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessStreamRestriction(Node* node, const std::string& AdID, uint64_t startMS)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessStreamRestrictionExt	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessStreamRestrictionExt(Node* node, const std::string& AdID, uint64_t startMS)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessStreamRestrictionList	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessStreamRestrictionList(Node* node, const std::string& AdID, uint64_t startMS)$/;"	f	class:PrivateStreamAbstractionMPD
ProcessTrickModeRestriction	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::ProcessTrickModeRestriction(Node* node, const std::string& AdID, uint64_t startMS)$/;"	f	class:PrivateStreamAbstractionMPD
ProfileBegin	priv_aamp.h	/^	void ProfileBegin(ProfilerBucketType type )$/;"	f	class:ProfileEventAAMP
ProfileEnd	priv_aamp.h	/^	void ProfileEnd( ProfilerBucketType type )$/;"	f	class:ProfileEventAAMP
ProfileError	priv_aamp.h	/^	void ProfileError(ProfilerBucketType type, int result = -1)$/;"	f	class:ProfileEventAAMP
ProfileEventAAMP	priv_aamp.h	/^	ProfileEventAAMP()$/;"	f	class:ProfileEventAAMP
ProfileEventAAMP	priv_aamp.h	/^class ProfileEventAAMP$/;"	c
ProfilePerformed	priv_aamp.h	/^	void ProfilePerformed(ProfilerBucketType type)$/;"	f	class:ProfileEventAAMP
ProfilerBucket	priv_aamp.h	/^	struct ProfilerBucket$/;"	s	class:ProfileEventAAMP
ProfilerBucketType	priv_aamp.h	/^} ProfilerBucketType;$/;"	t	typeref:enum:__anon23
ProgressCallbackOnTimeout	aampgstplayer.cpp	/^static gboolean ProgressCallbackOnTimeout(gpointer user_data)$/;"	f	file:
PushEncryptedHeaders	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::PushEncryptedHeaders()$/;"	f	class:PrivateStreamAbstractionMPD
PushFragment	main_aamp.cpp	/^void PrivateInstanceAAMP::PushFragment(MediaType mediaType, GrowableBuffer* buffer, double fragmentTime, double fragmentDuration)$/;"	f	class:PrivateInstanceAAMP
PushFragment	main_aamp.cpp	/^void PrivateInstanceAAMP::PushFragment(MediaType mediaType, char *ptr, size_t len, double fragmentTime, double fragmentDuration)$/;"	f	class:PrivateInstanceAAMP
PushNextFragment	fragmentcollector_mpd.cpp	/^bool PrivateStreamAbstractionMPD::PushNextFragment( struct MediaStreamContext *pMediaStreamContext, unsigned int curlInstance)$/;"	f	class:PrivateStreamAbstractionMPD
QueueProtectionEvent	aampgstplayer.cpp	/^void AAMPGstPlayer::QueueProtectionEvent(const char *protSystemId, const void *initData, size_t initDataSize)$/;"	f	class:AAMPGstPlayer
QueueProtectionEvent	main_aamp.h	/^	virtual void QueueProtectionEvent(const char *protSystemId, const void *ptr, size_t len) {};$/;"	f	class:StreamSink
RAND_STRING_LEN	streamabstraction.cpp	50;"	d	file:
RampDownProfile	streamabstraction.cpp	/^bool StreamAbstractionAAMP::RampDownProfile(long http_error)$/;"	f	class:StreamAbstractionAAMP
Read32	fragmentcollector_mpd.cpp	/^static unsigned int Read32( const char **pptr)$/;"	f	file:
ReadConfigStringHelper	main_aamp.cpp	/^static int ReadConfigStringHelper(const char *bufPtr, const char *prefixPtr, const char **valueCopyPtr)$/;"	f	file:
ReassessAndResumeAudioTrack	streamabstraction.cpp	/^void StreamAbstractionAAMP::ReassessAndResumeAudioTrack(bool abort)$/;"	f	class:StreamAbstractionAAMP
RecordingComponent	tsprocessor.h	/^struct RecordingComponent$/;"	s
RefreshPlaylist	fragmentcollector_hls.cpp	/^void TrackState::RefreshPlaylist(void)$/;"	f	class:TrackState
RegisterEvents	main_aamp.cpp	/^void PlayerInstanceAAMP::RegisterEvents(AAMPEventListener* eventListener)$/;"	f	class:PlayerInstanceAAMP
RegisterEvents	priv_aamp.h	/^	void RegisterEvents(AAMPEventListener* eventListener)$/;"	f	class:PrivateInstanceAAMP
RemapManifestUrl	main_aamp.cpp	/^static const char *RemapManifestUrl(const char *mainManifestUrl)$/;"	f	file:
RemoveEventListener	main_aamp.cpp	/^void PlayerInstanceAAMP::RemoveEventListener(AAMPEventType eventType, AAMPEventListener* eventListener)$/;"	f	class:PlayerInstanceAAMP
RemoveEventListener	main_aamp.cpp	/^void PrivateInstanceAAMP::RemoveEventListener(AAMPEventType eventType, AAMPEventListener* eventListener)$/;"	f	class:PrivateInstanceAAMP
ReportProgress	main_aamp.cpp	/^void PrivateInstanceAAMP::ReportProgress(void)$/;"	f	class:PrivateInstanceAAMP
ReportTimedMetadata	main_aamp.cpp	/^void PrivateInstanceAAMP::ReportTimedMetadata(double timeMilliseconds, const char* szName, const char* szContent, int nb)$/;"	f	class:PrivateInstanceAAMP
RepresentationID	fragmentcollector_mpd.cpp	/^	char RepresentationID[MAX_ID_SIZE]; \/\/ todo: retrieve from representation instead of making a copy$/;"	m	struct:FragmentDescriptor	file:
ResetCurrentlyAvailableBandwidth	main_aamp.cpp	/^void PrivateInstanceAAMP::ResetCurrentlyAvailableBandwidth(long bitsPerSecond , bool trickPlay,int profile)$/;"	f	class:PrivateInstanceAAMP
ResetESChangeStatus	StreamAbstractionAAMP.h	/^	void ResetESChangeStatus(void){ mESChangeStatus = false;}$/;"	f	class:StreamAbstractionAAMP
ResumeDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::ResumeDownloads()$/;"	f	class:PrivateInstanceAAMP
ResumeTrackDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::ResumeTrackDownloads(MediaType type)$/;"	f	class:PrivateInstanceAAMP
RetrieveFromPlaylistCache	main_aamp.cpp	/^bool PrivateInstanceAAMP::RetrieveFromPlaylistCache(const std::string url, GrowableBuffer* buffer, char effectiveUrl[])$/;"	f	class:PrivateInstanceAAMP
RewindPlaylist	fragmentcollector_hls.cpp	/^static char *RewindPlaylist(TrackState *trackState)$/;"	f	file:
RunFetchLoop	fragmentcollector_hls.cpp	/^void TrackState::RunFetchLoop()$/;"	f	class:TrackState
RunInjectLoop	streamabstraction.cpp	/^void MediaTrack::RunInjectLoop()$/;"	f	class:MediaTrack
SAP	priv_aamp.h	/^	bool SAP;                   \/**< Enable\/Disable Secondary Audio Program*\/$/;"	m	class:GlobalConfigAAMP
SCAN_REMAINDER_SIZE_H264	tsprocessor.h	80;"	d
SCAN_REMAINDER_SIZE_MPEG2	tsprocessor.h	79;"	d
SEGMENT_COUNT_FOR_ABR_CHECK	fragmentcollector_mpd.cpp	64;"	d	file:
SEQ_START	tsprocessor.cpp	107;"	d	file:
STREAMABSTRACTIONAAMP_H	StreamAbstractionAAMP.h	26;"	d
STR_PROXY_BUFF_SIZE	main_aamp.cpp	164;"	d	file:
ScheduleEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::ScheduleEvent(AsyncEventDescriptor* e)$/;"	f	class:PrivateInstanceAAMP
ScheduleRetune	main_aamp.cpp	/^void PrivateInstanceAAMP::ScheduleRetune(PlaybackErrorType errorType, MediaType trackType)$/;"	f	class:PrivateInstanceAAMP
Seek	main_aamp.cpp	/^void PlayerInstanceAAMP::Seek(double secondsRelativeToTuneTime)$/;"	f	class:PlayerInstanceAAMP
SeekInPeriod	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::SeekInPeriod( double seekPositionSeconds)$/;"	f	class:PrivateStreamAbstractionMPD
SeekToLive	main_aamp.cpp	/^void PlayerInstanceAAMP::SeekToLive()$/;"	f	class:PlayerInstanceAAMP
SelectAudio	aampgstplayer.cpp	/^void AAMPGstPlayer::SelectAudio(int index)$/;"	f	class:AAMPGstPlayer
SelectAudio	main_aamp.h	/^	virtual void SelectAudio(int index){}$/;"	f	class:StreamSink
Send	aampgstplayer.cpp	/^void AAMPGstPlayer::Send(MediaType mediaType, GrowableBuffer* pBuffer, double fpts, double fdts, double fDuration)$/;"	f	class:AAMPGstPlayer
Send	aampgstplayer.cpp	/^void AAMPGstPlayer::Send(MediaType mediaType, const void *ptr, size_t len0, double fpts, double fdts, double fDuration)$/;"	f	class:AAMPGstPlayer
SendAnomalyEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendAnomalyEvent(AAMPAnomalyMessageType type, const char* format, ...)$/;"	f	class:PrivateInstanceAAMP
SendAsynchronousEvent	main_aamp.cpp	/^static gboolean SendAsynchronousEvent(gpointer user_data)$/;"	f	file:
SendDRMMetaData	main_aamp.cpp	/^void PrivateInstanceAAMP::SendDRMMetaData(const AAMPEvent &e)$/;"	f	class:PrivateInstanceAAMP
SendDownloadErrorEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendDownloadErrorEvent(AAMPTuneFailure tuneFailure,long error_code)$/;"	f	class:PrivateInstanceAAMP
SendDrmErrorEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendDrmErrorEvent(AAMPTuneFailure tuneFailure,long error_code, bool isRetryEnabled)$/;"	f	class:PrivateInstanceAAMP
SendErrorEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendErrorEvent(AAMPTuneFailure tuneFailure, const char * description, bool isRetryEnabled)$/;"	f	class:PrivateInstanceAAMP
SendEventAsync	main_aamp.cpp	/^void PrivateInstanceAAMP::SendEventAsync(const AAMPEvent &e)$/;"	f	class:PrivateInstanceAAMP
SendEventSync	main_aamp.cpp	/^void PrivateInstanceAAMP::SendEventSync(const AAMPEvent &e)$/;"	f	class:PrivateInstanceAAMP
SendMediaMetadataEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendMediaMetadataEvent(double durationMs, std::set<std::string>langList, std::vector<long> bitrateList, bool hasDrm, bool isIframeTrackPresent)$/;"	f	class:PrivateInstanceAAMP
SendMessage2Receiver	main_aamp.cpp	/^void PrivateInstanceAAMP::SendMessage2Receiver(AAMP2ReceiverMsgType type, const char *data)$/;"	f	class:PrivateInstanceAAMP
SendMessageOverPipe	main_aamp.cpp	/^void PrivateInstanceAAMP::SendMessageOverPipe(const char *str,int nToWrite)$/;"	f	class:PrivateInstanceAAMP
SendStalledErrorEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendStalledErrorEvent()$/;"	f	class:PrivateInstanceAAMP
SendStream	main_aamp.cpp	/^void PrivateInstanceAAMP::SendStream(MediaType mediaType, GrowableBuffer* buffer, double fpts, double fdts, double fDuration)$/;"	f	class:PrivateInstanceAAMP
SendStream	main_aamp.cpp	/^void PrivateInstanceAAMP::SendStream(MediaType mediaType, const void *ptr, size_t len, double fpts, double fdts, double fDuration)$/;"	f	class:PrivateInstanceAAMP
SendSupportedSpeedsChangedEvent	main_aamp.cpp	/^void PrivateInstanceAAMP::SendSupportedSpeedsChangedEvent(bool isIframeTrackPresent)$/;"	f	class:PrivateInstanceAAMP
SendTunedEvent	main_aamp.cpp	/^bool PrivateInstanceAAMP::SendTunedEvent()$/;"	f	class:PrivateInstanceAAMP
SetAnonymousRequest	main_aamp.cpp	/^void PlayerInstanceAAMP::SetAnonymousRequest(bool isAnonymous)$/;"	f	class:PlayerInstanceAAMP
SetAnonymousRequest	main_aamp.cpp	/^void PrivateInstanceAAMP::SetAnonymousRequest(bool isAnonymous)$/;"	f	class:PrivateInstanceAAMP
SetAudioBitrate	main_aamp.cpp	/^void PlayerInstanceAAMP::SetAudioBitrate(long bitrate)$/;"	f	class:PlayerInstanceAAMP
SetAudioVolume	aampgstplayer.cpp	/^void AAMPGstPlayer::SetAudioVolume(int volume)$/;"	f	class:AAMPGstPlayer
SetAudioVolume	main_aamp.cpp	/^void PlayerInstanceAAMP::SetAudioVolume(int volume)$/;"	f	class:PlayerInstanceAAMP
SetAudioVolume	main_aamp.cpp	/^void PrivateInstanceAAMP::SetAudioVolume(int volume)$/;"	f	class:PrivateInstanceAAMP
SetAudioVolume	main_aamp.h	/^	virtual void SetAudioVolume(int volume){};$/;"	f	class:StreamSink
SetBandwidthBitsPerSecondAudio	priv_aamp.h	/^	void SetBandwidthBitsPerSecondAudio(long bw)$/;"	f	class:ProfileEventAAMP
SetBandwidthBitsPerSecondVideo	priv_aamp.h	/^	void SetBandwidthBitsPerSecondVideo(long bw)$/;"	f	class:ProfileEventAAMP
SetCallbackAsDispatched	main_aamp.cpp	/^void PrivateInstanceAAMP::SetCallbackAsDispatched(gint id)$/;"	f	class:PrivateInstanceAAMP
SetCallbackAsPending	main_aamp.cpp	/^void PrivateInstanceAAMP::SetCallbackAsPending(gint id)$/;"	f	class:PrivateInstanceAAMP
SetContentType	main_aamp.cpp	/^void PrivateInstanceAAMP::SetContentType(const char *mainManifestUrl, const char *cType)$/;"	f	class:PrivateInstanceAAMP
SetCurlTimeout	main_aamp.cpp	/^void PrivateInstanceAAMP::SetCurlTimeout(long timeout, unsigned int instance)$/;"	f	class:PrivateInstanceAAMP
SetCurrentBandWidth	streamabstraction.cpp	/^void MediaTrack::SetCurrentBandWidth(int bandwidthBps)$/;"	f	class:MediaTrack
SetDownloadBufferSize	main_aamp.cpp	/^void PlayerInstanceAAMP::SetDownloadBufferSize(int bufferSize)$/;"	f	class:PlayerInstanceAAMP
SetDownloadBufferSize	main_aamp.cpp	/^void PrivateInstanceAAMP::SetDownloadBufferSize(int bufferSize)$/;"	f	class:PrivateInstanceAAMP
SetDrmContextUnlocked	fragmentcollector_hls.cpp	/^void TrackState::SetDrmContextUnlocked()$/;"	f	class:TrackState
SetDrmErrorCode	priv_aamp.h	/^	void SetDrmErrorCode(int errCode)$/;"	f	class:ProfileEventAAMP
SetESChangeStatus	StreamAbstractionAAMP.h	/^	void SetESChangeStatus(void){ mESChangeStatus = true;}$/;"	f	class:StreamAbstractionAAMP
SetEndPos	StreamAbstractionAAMP.h	/^	virtual void SetEndPos(double endPosition){};$/;"	f	class:StreamAbstractionAAMP
SetEndPos	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::SetEndPos(double endPosition)$/;"	f	class:PrivateStreamAbstractionMPD
SetEndPos	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::SetEndPos(double endPosition)$/;"	f	class:StreamAbstractionAAMP_MPD
SetInitialBitrate	main_aamp.cpp	/^void PlayerInstanceAAMP::SetInitialBitrate(long bitrate)$/;"	f	class:PlayerInstanceAAMP
SetInitialBitrate	main_aamp.cpp	/^void PrivateInstanceAAMP::SetInitialBitrate(long bitrate)$/;"	f	class:PrivateInstanceAAMP
SetInitialBitrate4K	main_aamp.cpp	/^void PlayerInstanceAAMP::SetInitialBitrate4K(long bitrate4K)$/;"	f	class:PlayerInstanceAAMP
SetInitialBitrate4K	main_aamp.cpp	/^void PrivateInstanceAAMP::SetInitialBitrate4K(long bitrate4K)$/;"	f	class:PrivateInstanceAAMP
SetIsLive	priv_aamp.h	/^	void SetIsLive(bool isLive)  {mIsLive = isLive; }$/;"	f	class:PrivateInstanceAAMP
SetLanguage	main_aamp.cpp	/^void PlayerInstanceAAMP::SetLanguage(const char* language)$/;"	f	class:PlayerInstanceAAMP
SetLicenseReqProxy	main_aamp.cpp	/^void PlayerInstanceAAMP::SetLicenseReqProxy(const char * licenseProxy)$/;"	f	class:PlayerInstanceAAMP
SetLicenseReqProxy	main_aamp.cpp	/^void PrivateInstanceAAMP::SetLicenseReqProxy(const char * licenseProxy)$/;"	f	class:PrivateInstanceAAMP
SetLicenseServerURL	main_aamp.cpp	/^void PlayerInstanceAAMP::SetLicenseServerURL(const char *url, DRMSystems type)$/;"	f	class:PlayerInstanceAAMP
SetLicenseServerURL	main_aamp.cpp	/^void PrivateInstanceAAMP::SetLicenseServerURL(const char *url, DRMSystems type)$/;"	f	class:PrivateInstanceAAMP
SetLinearTrickplayFPS	main_aamp.cpp	/^void PlayerInstanceAAMP::SetLinearTrickplayFPS(int linearTrickplayFPS)$/;"	f	class:PlayerInstanceAAMP
SetLinearTrickplayFPS	main_aamp.cpp	/^void PrivateInstanceAAMP::SetLinearTrickplayFPS(int linearTrickplayFPS)$/;"	f	class:PrivateInstanceAAMP
SetLiveOffset	main_aamp.cpp	/^void PlayerInstanceAAMP::SetLiveOffset(int liveoffset)$/;"	f	class:PlayerInstanceAAMP
SetLiveOffset	main_aamp.cpp	/^void PrivateInstanceAAMP::SetLiveOffset(int liveoffset)$/;"	f	class:PrivateInstanceAAMP
SetManifestUrl	priv_aamp.h	/^	void SetManifestUrl(const char *url)$/;"	f	class:PrivateInstanceAAMP
SetNetworkProxy	main_aamp.cpp	/^void PlayerInstanceAAMP::SetNetworkProxy(const char * proxy)$/;"	f	class:PlayerInstanceAAMP
SetNetworkProxy	main_aamp.cpp	/^void PrivateInstanceAAMP::SetNetworkProxy(const char * proxy)$/;"	f	class:PrivateInstanceAAMP
SetNetworkTimeout	main_aamp.cpp	/^void PlayerInstanceAAMP::SetNetworkTimeout(int timeout)$/;"	f	class:PlayerInstanceAAMP
SetNetworkTimeout	main_aamp.cpp	/^void PrivateInstanceAAMP::SetNetworkTimeout(int timeout)$/;"	f	class:PrivateInstanceAAMP
SetPersistedBandwidth	priv_aamp.h	/^	void SetPersistedBandwidth(long bandwidth) {mAvailableBandwidth = bandwidth;}$/;"	f	class:PrivateInstanceAAMP
SetPersistedProfileIndex	priv_aamp.h	/^	void SetPersistedProfileIndex(int profile){mPersistedProfileIndex = profile;}$/;"	f	class:PrivateInstanceAAMP
SetPreferredDRM	main_aamp.cpp	/^void PlayerInstanceAAMP::SetPreferredDRM(DRMSystems drmType)$/;"	f	class:PlayerInstanceAAMP
SetPreferredDRM	main_aamp.cpp	/^void PrivateInstanceAAMP::SetPreferredDRM(DRMSystems drmType)$/;"	f	class:PrivateInstanceAAMP
SetRate	main_aamp.cpp	/^void PlayerInstanceAAMP::SetRate(int rate,int overshootcorrection)$/;"	f	class:PlayerInstanceAAMP
SetRateAndSeek	main_aamp.cpp	/^void PlayerInstanceAAMP::SetRateAndSeek(int rate, double secondsRelativeToTuneTime)$/;"	f	class:PlayerInstanceAAMP
SetReportInterval	main_aamp.cpp	/^void PlayerInstanceAAMP::SetReportInterval(int reportIntervalMS)$/;"	f	class:PlayerInstanceAAMP
SetReportInterval	main_aamp.cpp	/^void PrivateInstanceAAMP::SetReportInterval(int reportIntervalMS)$/;"	f	class:PrivateInstanceAAMP
SetStallErrorCode	main_aamp.cpp	/^void PlayerInstanceAAMP::SetStallErrorCode(int errorCode)$/;"	f	class:PlayerInstanceAAMP
SetStallErrorCode	main_aamp.cpp	/^void PrivateInstanceAAMP::SetStallErrorCode(int errorCode)$/;"	f	class:PrivateInstanceAAMP
SetStallTimeout	main_aamp.cpp	/^void PlayerInstanceAAMP::SetStallTimeout(int timeoutMS)$/;"	f	class:PlayerInstanceAAMP
SetStallTimeout	main_aamp.cpp	/^void PrivateInstanceAAMP::SetStallTimeout(int timeoutMS)$/;"	f	class:PrivateInstanceAAMP
SetState	main_aamp.cpp	/^void PrivateInstanceAAMP::SetState(PrivAAMPState state)$/;"	f	class:PrivateInstanceAAMP
SetStreamSink	main_aamp.cpp	/^void PrivateInstanceAAMP::SetStreamSink(StreamSink* streamSink)$/;"	f	class:PrivateInstanceAAMP
SetSubscribedTags	main_aamp.cpp	/^void PlayerInstanceAAMP::SetSubscribedTags(std::vector<std::string> subscribedTags)$/;"	f	class:PlayerInstanceAAMP
SetTsbBandwidth	StreamAbstractionAAMP.h	/^	void SetTsbBandwidth(long tsbBandwidth){ mTsbBandwidth = tsbBandwidth;}$/;"	f	class:StreamAbstractionAAMP
SetTunedManifestUrl	main_aamp.cpp	/^void PrivateInstanceAAMP::SetTunedManifestUrl(bool isrecordedUrl)$/;"	f	class:PrivateInstanceAAMP
SetVODTrickplayFPS	main_aamp.cpp	/^void PlayerInstanceAAMP::SetVODTrickplayFPS(int vodTrickplayFPS)$/;"	f	class:PlayerInstanceAAMP
SetVODTrickplayFPS	main_aamp.cpp	/^void PrivateInstanceAAMP::SetVODTrickplayFPS(int vodTrickplayFPS)$/;"	f	class:PrivateInstanceAAMP
SetVideoBitrate	main_aamp.cpp	/^void PlayerInstanceAAMP::SetVideoBitrate(long bitrate)$/;"	f	class:PlayerInstanceAAMP
SetVideoBitrate	main_aamp.cpp	/^void PrivateInstanceAAMP::SetVideoBitrate(long bitrate)$/;"	f	class:PrivateInstanceAAMP
SetVideoMute	aampgstplayer.cpp	/^void AAMPGstPlayer::SetVideoMute(bool muted)$/;"	f	class:AAMPGstPlayer
SetVideoMute	main_aamp.cpp	/^void PlayerInstanceAAMP::SetVideoMute(bool muted)$/;"	f	class:PlayerInstanceAAMP
SetVideoMute	main_aamp.cpp	/^void PrivateInstanceAAMP::SetVideoMute(bool muted)$/;"	f	class:PrivateInstanceAAMP
SetVideoMute	main_aamp.h	/^	virtual void SetVideoMute(bool muted){};$/;"	f	class:StreamSink
SetVideoRectangle	aampgstplayer.cpp	/^void AAMPGstPlayer::SetVideoRectangle(int x, int y, int w, int h)$/;"	f	class:AAMPGstPlayer
SetVideoRectangle	main_aamp.cpp	/^void PlayerInstanceAAMP::SetVideoRectangle(int x, int y, int w, int h)$/;"	f	class:PlayerInstanceAAMP
SetVideoRectangle	main_aamp.cpp	/^void PrivateInstanceAAMP::SetVideoRectangle(int x, int y, int w, int h)$/;"	f	class:PrivateInstanceAAMP
SetVideoRectangle	main_aamp.h	/^	virtual void SetVideoRectangle(int x, int y, int w, int h){};$/;"	f	class:StreamSink
SetVideoZoom	aampgstplayer.cpp	/^void AAMPGstPlayer::SetVideoZoom(VideoZoomMode zoom)$/;"	f	class:AAMPGstPlayer
SetVideoZoom	main_aamp.cpp	/^void PlayerInstanceAAMP::SetVideoZoom(VideoZoomMode zoom)$/;"	f	class:PlayerInstanceAAMP
SetVideoZoom	main_aamp.cpp	/^void PrivateInstanceAAMP::SetVideoZoom(VideoZoomMode zoom)$/;"	f	class:PrivateInstanceAAMP
SetVideoZoom	main_aamp.h	/^	virtual void SetVideoZoom(VideoZoomMode zoom){};$/;"	f	class:StreamSink
SetupPipeSession	main_aamp.cpp	/^bool PrivateInstanceAAMP::SetupPipeSession()$/;"	f	class:PrivateInstanceAAMP
SkipFragments	fragmentcollector_mpd.cpp	/^double PrivateStreamAbstractionMPD::SkipFragments( MediaStreamContext *pMediaStreamContext, double skipTime, bool updateFirstPTS)$/;"	f	class:PrivateStreamAbstractionMPD
SkipToEnd	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::SkipToEnd( MediaStreamContext *pMediaStreamContext)$/;"	f	class:PrivateStreamAbstractionMPD
Start	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::Start(void)$/;"	f	class:StreamAbstractionAAMP_HLS
Start	fragmentcollector_hls.cpp	/^void TrackState::Start(void)$/;"	f	class:TrackState
Start	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::Start(void)$/;"	f	class:PrivateStreamAbstractionMPD
Start	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::Start(void)$/;"	f	class:StreamAbstractionAAMP_MPD
StartDeferredDrmLicenseAcquisition	fragmentcollector_hls.cpp	/^void TrackState::StartDeferredDrmLicenseAcquisition()$/;"	f	class:TrackState
StartInjectLoop	streamabstraction.cpp	/^void MediaTrack::StartInjectLoop()$/;"	f	class:MediaTrack
StartInjection	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::StartInjection(void)$/;"	f	class:StreamAbstractionAAMP_HLS
StartInjection	fragmentcollector_hls.cpp	/^void TrackState::StartInjection()$/;"	f	class:TrackState
StartInjection	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::StartInjection(void)$/;"	f	class:PrivateStreamAbstractionMPD
StartInjection	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::StartInjection(void)$/;"	f	class:StreamAbstractionAAMP_MPD
Stop	aampgstplayer.cpp	/^void AAMPGstPlayer::Stop(bool keepLastFrame)$/;"	f	class:AAMPGstPlayer
Stop	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::Stop(bool clearChannelData)$/;"	f	class:StreamAbstractionAAMP_HLS
Stop	fragmentcollector_hls.cpp	/^void TrackState::Stop(bool clearDRM)$/;"	f	class:TrackState
Stop	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::Stop()$/;"	f	class:PrivateStreamAbstractionMPD
Stop	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::Stop(bool clearChannelData)$/;"	f	class:StreamAbstractionAAMP_MPD
Stop	main_aamp.cpp	/^void PlayerInstanceAAMP::Stop(void)$/;"	f	class:PlayerInstanceAAMP
Stop	main_aamp.cpp	/^void PrivateInstanceAAMP::Stop()$/;"	f	class:PrivateInstanceAAMP
Stop	main_aamp.h	/^	virtual void Stop(bool keepLastFrame){}$/;"	f	class:StreamSink
StopDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::StopDownloads()$/;"	f	class:PrivateInstanceAAMP
StopInjectLoop	streamabstraction.cpp	/^void MediaTrack::StopInjectLoop()$/;"	f	class:MediaTrack
StopInjection	fragmentcollector_hls.cpp	/^void StreamAbstractionAAMP_HLS::StopInjection(void)$/;"	f	class:StreamAbstractionAAMP_HLS
StopInjection	fragmentcollector_hls.cpp	/^void TrackState::StopInjection()$/;"	f	class:TrackState
StopInjection	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::StopInjection(void)$/;"	f	class:PrivateStreamAbstractionMPD
StopInjection	fragmentcollector_mpd.cpp	/^void StreamAbstractionAAMP_MPD::StopInjection(void)$/;"	f	class:StreamAbstractionAAMP_MPD
StopTrackDownloads	main_aamp.cpp	/^void PrivateInstanceAAMP::StopTrackDownloads(MediaType type)$/;"	f	class:PrivateInstanceAAMP
StopWaitForPlaylistRefresh	fragmentcollector_hls.cpp	/^void TrackState::StopWaitForPlaylistRefresh()$/;"	f	class:TrackState
StoreLanguageList	main_aamp.cpp	/^void PrivateInstanceAAMP::StoreLanguageList(int maxLangCount , char langlist[][MAX_LANGUAGE_TAG_LENGTH])$/;"	f	class:PrivateInstanceAAMP
Stream	aampgstplayer.cpp	/^void AAMPGstPlayer::Stream()$/;"	f	class:AAMPGstPlayer
Stream	main_aamp.h	/^	virtual void Stream(void){}$/;"	f	class:StreamSink
StreamAbstractionAAMP	StreamAbstractionAAMP.h	/^class StreamAbstractionAAMP$/;"	c
StreamAbstractionAAMP	streamabstraction.cpp	/^StreamAbstractionAAMP::StreamAbstractionAAMP(PrivateInstanceAAMP* aamp):$/;"	f	class:StreamAbstractionAAMP
StreamAbstractionAAMP_HLS	fragmentcollector_hls.cpp	/^StreamAbstractionAAMP_HLS::StreamAbstractionAAMP_HLS(class PrivateInstanceAAMP *aamp,double seekpos, float rate, bool enableThrottle) : StreamAbstractionAAMP(aamp)$/;"	f	class:StreamAbstractionAAMP_HLS
StreamAbstractionAAMP_HLS	fragmentcollector_hls.h	/^class StreamAbstractionAAMP_HLS : public StreamAbstractionAAMP$/;"	c
StreamAbstractionAAMP_MPD	fragmentcollector_mpd.cpp	/^StreamAbstractionAAMP_MPD::StreamAbstractionAAMP_MPD(class PrivateInstanceAAMP *aamp,double seek_pos, float rate): StreamAbstractionAAMP(aamp)$/;"	f	class:StreamAbstractionAAMP_MPD
StreamAbstractionAAMP_MPD	fragmentcollector_mpd.h	/^class StreamAbstractionAAMP_MPD : public StreamAbstractionAAMP$/;"	c
StreamInfo	StreamAbstractionAAMP.h	/^struct StreamInfo$/;"	s
StreamOperation	tsprocessor.h	/^}StreamOperation;$/;"	t	typeref:enum:__anon25
StreamOutputFormat	main_aamp.h	/^enum StreamOutputFormat$/;"	g
StreamResolution	StreamAbstractionAAMP.h	/^struct StreamResolution$/;"	s
StreamSelection	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::StreamSelection( bool newTune)$/;"	f	class:PrivateStreamAbstractionMPD
StreamSink	main_aamp.h	/^class StreamSink$/;"	c
SubStringMatch	fragmentcollector_hls.cpp	/^static bool SubStringMatch(const char *srcStart, const char *srcFin, const char *cstring)$/;"	f	file:
SyncBegin	main_aamp.cpp	/^void PrivateInstanceAAMP::SyncBegin(void)$/;"	f	class:PrivateInstanceAAMP
SyncEnd	main_aamp.cpp	/^void PrivateInstanceAAMP::SyncEnd(void)$/;"	f	class:PrivateInstanceAAMP
SyncTracks	fragmentcollector_hls.cpp	/^AAMPStatusType StreamAbstractionAAMP_HLS::SyncTracks(bool useProgramDateTimeIfAvailable)$/;"	f	class:StreamAbstractionAAMP_HLS
SyncTracksForDiscontinuity	fragmentcollector_hls.cpp	/^AAMPStatusType StreamAbstractionAAMP_HLS::SyncTracksForDiscontinuity()$/;"	f	class:StreamAbstractionAAMP_HLS
TIMELINE_START_RESET_DIFF	fragmentcollector_mpd.cpp	68;"	d	file:
TRACE1	tsprocessor.cpp	50;"	d	file:
TRACE1	tsprocessor.cpp	55;"	d	file:
TRACE2	tsprocessor.cpp	51;"	d	file:
TRACE2	tsprocessor.cpp	56;"	d	file:
TRACE3	tsprocessor.cpp	52;"	d	file:
TRACE3	tsprocessor.cpp	57;"	d	file:
TRACE4	tsprocessor.cpp	53;"	d	file:
TRACE4	tsprocessor.cpp	58;"	d	file:
TRICKPLAY_NETWORK_PLAYBACK_FPS	priv_aamp.h	76;"	d
TRICKPLAY_TSB_PLAYBACK_FPS	priv_aamp.h	77;"	d
TSProcessor	tsprocessor.cpp	/^TSProcessor::TSProcessor(class PrivateInstanceAAMP *aamp,StreamOperation streamOperation, int track, TSProcessor* peerTSProcessor)$/;"	f	class:TSProcessor
TSProcessor	tsprocessor.h	/^class TSProcessor$/;"	c
TearDownStream	aampgstplayer.cpp	/^void AAMPGstPlayer::TearDownStream(MediaType mediaType)$/;"	f	class:AAMPGstPlayer
TeardownStream	main_aamp.cpp	/^void PrivateInstanceAAMP::TeardownStream(bool newTune)$/;"	f	class:PrivateInstanceAAMP
Time	fragmentcollector_mpd.cpp	/^	uint64_t Time;$/;"	m	struct:FragmentDescriptor	file:
TimedMetadata	priv_aamp.h	/^	TimedMetadata() : _timeMS(0), _name(""), _content("") {}$/;"	f	class:TimedMetadata
TimedMetadata	priv_aamp.h	/^	TimedMetadata(double timeMS, std::string name, std::string content) : _timeMS(timeMS), _name(name), _content(content) {}$/;"	f	class:TimedMetadata
TimedMetadata	priv_aamp.h	/^class TimedMetadata$/;"	c
TrackDownloader	fragmentcollector_mpd.cpp	/^void * TrackDownloader(void *arg)$/;"	f
TrackPLDownloader	fragmentcollector_hls.cpp	/^static void * TrackPLDownloader(void *arg)$/;"	f	file:
TrackState	fragmentcollector_hls.cpp	/^TrackState::TrackState(TrackType type, StreamAbstractionAAMP_HLS* parent, PrivateInstanceAAMP* aamp, const char* name) :$/;"	f	class:TrackState
TrackState	fragmentcollector_hls.h	/^class TrackState : public MediaTrack$/;"	c
TrackToDemux	tsprocessor.h	/^}TrackToDemux;$/;"	t	typeref:enum:__anon26
TrackType	StreamAbstractionAAMP.h	/^} TrackType;$/;"	t	typeref:enum:__anon1
Tune	main_aamp.cpp	/^void PlayerInstanceAAMP::Tune(const char *mainManifestUrl, const char *contentType, bool bFirstAttempt, bool bFinalAttempt)$/;"	f	class:PlayerInstanceAAMP
Tune	main_aamp.cpp	/^void PrivateInstanceAAMP::Tune(const char *mainManifestUrl, const char *contentType, bool bFirstAttempt, bool bFinalAttempt)$/;"	f	class:PrivateInstanceAAMP
TuneBegin	priv_aamp.h	/^	void TuneBegin(void)$/;"	f	class:ProfileEventAAMP
TuneEnd	priv_aamp.h	/^	void TuneEnd(bool success, ContentType contentType, int streamType, bool firstTune)$/;"	f	class:ProfileEventAAMP
TuneEvent	priv_aamp.h	/^		TuneEvent(ProfilerBucketType i, unsigned int s,$/;"	f	class:ProfileEventAAMP::TuneEvent
TuneEvent	priv_aamp.h	/^    class TuneEvent$/;"	c	class:ProfileEventAAMP
TuneFailureMap	main_aamp.h	/^struct TuneFailureMap$/;"	s
TuneHelper	main_aamp.cpp	/^void PrivateInstanceAAMP::TuneHelper(TuneType tuneType)$/;"	f	class:PrivateInstanceAAMP
TuneTimeBackToXre	priv_aamp.h	/^	TuneTimeBackToXre,          \/**< Tune status back to XRE time*\/$/;"	e	enum:__anon24
TuneTimeBaseTime	priv_aamp.h	/^	TuneTimeBaseTime,           \/**< Tune time base*\/$/;"	e	enum:__anon24
TuneTimeBeginLoad	priv_aamp.h	/^	TuneTimeBeginLoad,          \/**< Player load time*\/$/;"	e	enum:__anon24
TuneTimeDrmReady	priv_aamp.h	/^	TuneTimeDrmReady,           \/**< DRM ready time*\/$/;"	e	enum:__anon24
TuneTimeMax	priv_aamp.h	/^	TuneTimeMax                 \/**< Max bucket type*\/$/;"	e	enum:__anon24
TuneTimePlay	priv_aamp.h	/^	TuneTimePlay,               \/**< Profiles ready time*\/$/;"	e	enum:__anon24
TuneTimePrepareToPlay	priv_aamp.h	/^	TuneTimePrepareToPlay,      \/**< Manifest ready time*\/$/;"	e	enum:__anon24
TuneTimeStartStream	priv_aamp.h	/^	TuneTimeStartStream,        \/**< First buffer insert time*\/$/;"	e	enum:__anon24
TuneTimeStreaming	priv_aamp.h	/^	TuneTimeStreaming,          \/**< First frame display time*\/$/;"	e	enum:__anon24
TuneType	priv_aamp.h	/^enum TuneType$/;"	g
TunedEventConfig	priv_aamp.h	/^enum TunedEventConfig$/;"	g
URAND_STRING_LEN	streamabstraction.cpp	49;"	d	file:
USE_IDLE_LOOP_FOR_PROGRESS_REPORTING	aampgstplayer.cpp	83;"	d	file:
UnloadJS	main_aamp.cpp	/^void PlayerInstanceAAMP::UnloadJS(void* context)$/;"	f	class:PlayerInstanceAAMP
UpdateAudioLanguageSelection	main_aamp.cpp	/^void PrivateInstanceAAMP::UpdateAudioLanguageSelection(const char *lang)$/;"	f	class:PrivateInstanceAAMP
UpdateCullingState	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::UpdateCullingState()$/;"	f	class:PrivateStreamAbstractionMPD
UpdateCullingState	main_aamp.cpp	/^void PrivateInstanceAAMP::UpdateCullingState(double culledSecs)$/;"	f	class:PrivateInstanceAAMP
UpdateDrmCMSha1Hash	fragmentcollector_hls.cpp	/^void TrackState::UpdateDrmCMSha1Hash(const char *ptr)$/;"	f	class:TrackState
UpdateDrmIV	fragmentcollector_hls.cpp	/^void TrackState::UpdateDrmIV(const char *ptr)$/;"	f	class:TrackState
UpdateDuration	main_aamp.cpp	/^void PrivateInstanceAAMP::UpdateDuration(double seconds)$/;"	f	class:PrivateInstanceAAMP
UpdateIframeTracks	streamabstraction.cpp	/^void StreamAbstractionAAMP::UpdateIframeTracks()$/;"	f	class:StreamAbstractionAAMP
UpdateLanguageList	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::UpdateLanguageList()$/;"	f	class:PrivateStreamAbstractionMPD
UpdateMPD	fragmentcollector_mpd.cpp	/^AAMPStatusType PrivateStreamAbstractionMPD::UpdateMPD(bool retrievePlaylistFromCache)$/;"	f	class:PrivateStreamAbstractionMPD
UpdateProfileBasedOnFragmentCache	streamabstraction.cpp	/^bool StreamAbstractionAAMP::UpdateProfileBasedOnFragmentCache()$/;"	f	class:StreamAbstractionAAMP
UpdateProfileBasedOnFragmentDownloaded	streamabstraction.cpp	/^void StreamAbstractionAAMP::UpdateProfileBasedOnFragmentDownloaded(void)$/;"	f	class:StreamAbstractionAAMP
UpdateRefreshPlaylistInterval	main_aamp.cpp	/^void PrivateInstanceAAMP::UpdateRefreshPlaylistInterval(float maxIntervalSecs)$/;"	f	class:PrivateInstanceAAMP
UpdateTSAfterFetch	streamabstraction.cpp	/^void MediaTrack::UpdateTSAfterFetch()$/;"	f	class:MediaTrack
UpdateTSAfterInject	streamabstraction.cpp	/^void MediaTrack::UpdateTSAfterInject()$/;"	f	class:MediaTrack
UpdateTrackInfo	fragmentcollector_mpd.cpp	/^void PrivateStreamAbstractionMPD::UpdateTrackInfo(bool modifyDefaultBW, bool periodChanged, bool resetTimeLineIndex)$/;"	f	class:PrivateStreamAbstractionMPD
VALIDATE_INT	main_aamp.cpp	168;"	d	file:
VALIDATE_LONG	main_aamp.cpp	174;"	d	file:
VIDEO_ZOOM_FULL	main_aamp.h	/^	VIDEO_ZOOM_FULL,    \/**< Video Zoom Enabled *\/$/;"	e	enum:VideoZoomMode
VIDEO_ZOOM_NONE	main_aamp.h	/^	VIDEO_ZOOM_NONE     \/**< Video Zoom Disabled *\/$/;"	e	enum:VideoZoomMode
VideoDecoderPtsCheckerForEOS	aampgstplayer.cpp	/^static gboolean VideoDecoderPtsCheckerForEOS(gpointer user_data)$/;"	f	file:
VideoZoomMode	main_aamp.h	/^enum VideoZoomMode$/;"	g
WAIT_FOR_DATA_MAX_RETRIES	tsprocessor.cpp	93;"	d	file:
WAIT_FOR_DATA_MILLISEC	tsprocessor.cpp	92;"	d	file:
WARNING	tsprocessor.cpp	74;"	d	file:
WARNING	tsprocessor.cpp	79;"	d	file:
WIDEVINE_SYSTEM_ID	fragmentcollector_mpd.cpp	66;"	d	file:
WaitForCachedFragmentAvailable	streamabstraction.cpp	/^bool MediaTrack::WaitForCachedFragmentAvailable()$/;"	f	class:MediaTrack
WaitForFreeFragmentAvailable	streamabstraction.cpp	/^bool MediaTrack::WaitForFreeFragmentAvailable( int timeoutMs)$/;"	f	class:MediaTrack
WaitForVideoTrackCatchup	streamabstraction.cpp	/^void StreamAbstractionAAMP::WaitForVideoTrackCatchup()$/;"	f	class:StreamAbstractionAAMP
WriteFile	fragmentcollector_mpd.cpp	/^static void WriteFile(char* fileName, const char* data, int len)$/;"	f	file:
_AAMP2ReceiverMsg	priv_aamp.h	/^	typedef struct AAMP_PACKED _AAMP2ReceiverMsg$/;"	s	class:PrivateInstanceAAMP
_H264PPS	tsprocessor.h	/^      typedef struct _H264PPS$/;"	s	class:TSProcessor
_H264SPS	tsprocessor.h	/^      typedef struct _H264SPS$/;"	s	class:TSProcessor
_PlayMode	tsprocessor.h	/^typedef enum _PlayMode$/;"	g
_TSPROCESSOR_H	tsprocessor.h	26;"	d
__AAMP_COCOA_WINDOW_H	cocoa_window.h	25;"	d
_content	priv_aamp.h	/^	std::string _content;    \/**< Metadata content *\/$/;"	m	class:TimedMetadata
_name	priv_aamp.h	/^	std::string _name;       \/**< Metadata name *\/$/;"	m	class:TimedMetadata
_timeMS	priv_aamp.h	/^	double      _timeMS;     \/**< Time in milliseconds *\/$/;"	m	class:TimedMetadata
aamp	StreamAbstractionAAMP.h	/^	PrivateInstanceAAMP* aamp;          \/**< Pointer to the PrivateInstanceAAMP*\/$/;"	m	class:MediaTrack
aamp	StreamAbstractionAAMP.h	/^	PrivateInstanceAAMP* aamp;  \/**< Pointer to PrivateInstanceAAMP object associated with stream*\/$/;"	m	class:StreamAbstractionAAMP
aamp	aampgstplayer.h	/^	class PrivateInstanceAAMP *aamp;$/;"	m	class:AAMPGstPlayer	typeref:class:AAMPGstPlayer::PrivateInstanceAAMP
aamp	fragmentcollector_mpd.cpp	/^	PrivateInstanceAAMP *aamp;$/;"	m	class:PrivateStreamAbstractionMPD	file:
aamp	fragmentcollector_mpd.cpp	/^	PrivateInstanceAAMP *aamp;$/;"	m	struct:DrmSessionParams	file:
aamp	main_aamp.cpp	/^	PrivateInstanceAAMP *aamp;$/;"	m	struct:CurlCallbackContext	file:
aamp	main_aamp.cpp	/^	PrivateInstanceAAMP* aamp;$/;"	m	struct:AsyncEventDescriptor	file:
aamp	main_aamp.h	/^	class PrivateInstanceAAMP *aamp;    \/**< AAMP player's private instance *\/$/;"	m	class:PlayerInstanceAAMP	typeref:class:PlayerInstanceAAMP::PrivateInstanceAAMP
aamp	tsprocessor.cpp	/^	class PrivateInstanceAAMP *aamp;$/;"	m	class:Demuxer	typeref:class:Demuxer::PrivateInstanceAAMP	file:
aamp	tsprocessor.h	/^      class PrivateInstanceAAMP *aamp;$/;"	m	class:TSProcessor	typeref:class:TSProcessor::PrivateInstanceAAMP
aampLoglevel	priv_aamp.h	/^	AAMP_LogLevel aampLoglevel;$/;"	m	class:AampLogManager
aamp_AppendBytes	main_aamp.cpp	/^void aamp_AppendBytes(struct GrowableBuffer *buffer, const void *ptr, size_t len)$/;"	f
aamp_AppendNulTerminator	main_aamp.cpp	/^void aamp_AppendNulTerminator(struct GrowableBuffer *buffer)$/;"	f
aamp_CCHide	main_aamp.cpp	/^int aamp_CCHide(void)$/;"	f
aamp_CCShow	main_aamp.cpp	/^int aamp_CCShow(void)$/;"	f
aamp_CCStart	main_aamp.cpp	/^int aamp_CCStart(void *handle)$/;"	f
aamp_CCStop	main_aamp.cpp	/^void aamp_CCStop(void)$/;"	f
aamp_Error	main_aamp.cpp	/^void aamp_Error(const char *msg)$/;"	f
aamp_Free	main_aamp.cpp	/^void aamp_Free(char **pptr)$/;"	f
aamp_GetCCStatus	priv_aamp.h	/^	bool aamp_GetCCStatus(void)$/;"	f	class:GlobalConfigAAMP
aamp_GetCurrentTimeMS	main_aamp.cpp	/^long long aamp_GetCurrentTimeMS(void)$/;"	f
aamp_GetSAP	priv_aamp.h	/^	bool aamp_GetSAP(void)$/;"	f	class:GlobalConfigAAMP
aamp_IsCCEnabled	main_aamp.cpp	/^bool aamp_IsCCEnabled(void)$/;"	f
aamp_Malloc	main_aamp.cpp	/^void aamp_Malloc(struct GrowableBuffer *buffer, size_t len)$/;"	f
aamp_ResolveURL	main_aamp.cpp	/^void aamp_ResolveURL(char *dst, const char *base, const char *uri)$/;"	f
aamp_SetCCStatus	priv_aamp.h	/^	void aamp_SetCCStatus(bool on)$/;"	f	class:GlobalConfigAAMP
aamp_SetSAP	priv_aamp.h	/^	void aamp_SetSAP(bool on)$/;"	f	class:GlobalConfigAAMP
aamp_getHostFromURL	main_aamp.cpp	/^std::string aamp_getHostFromURL(char *url)$/;"	f
aamp_pthread_setname	priv_aamp.h	45;"	d
aamp_pthread_setname	priv_aamp.h	47;"	d
abort	StreamAbstractionAAMP.h	/^	bool abort;                         \/**< Abort all operations if flag is set*\/$/;"	m	class:MediaTrack
abort	tsprocessor.cpp	/^void TSProcessor::abort()$/;"	f	class:TSProcessor
abortUnlocked	tsprocessor.cpp	/^void TSProcessor::abortUnlocked()$/;"	f	class:TSProcessor
abortWait	StreamAbstractionAAMP.h	/^	bool abortWait;$/;"	m	class:StreamAbstractionAAMP
abrCacheLength	priv_aamp.h	/^	int abrCacheLength;                     \/**< Adaptive bitrate cache length*\/$/;"	m	class:GlobalConfigAAMP
abrCacheLife	priv_aamp.h	/^	int abrCacheLife;                       \/**< Adaptive bitrate cache life in seconds*\/$/;"	m	class:GlobalConfigAAMP
abrCalledFor	priv_aamp.h	/^	AAMPAbrType abrCalledFor;$/;"	m	struct:AAMPAbrInfo
abrNwConsistency	priv_aamp.h	/^	int abrNwConsistency;                   \/**< Adaptive bitrate network consistency*\/$/;"	m	class:GlobalConfigAAMP
abrOutlierDiffBytes	priv_aamp.h	/^	int abrOutlierDiffBytes;                \/**< Adaptive bitrate outlier, if values goes beyond this*\/$/;"	m	class:GlobalConfigAAMP
abrSkipDuration	priv_aamp.h	/^	int abrSkipDuration;                    \/**< Initial duration for ABR skip*\/$/;"	m	class:GlobalConfigAAMP
accessStatus	main_aamp.h	/^			const char *accessStatus;$/;"	m	struct:AAMPEvent::__anon9::__anon19
accessStatus_value	main_aamp.h	/^			int accessStatus_value;$/;"	m	struct:AAMPEvent::__anon9::__anon19
adPositionSec	priv_aamp.h	/^	int adPositionSec;                      \/**< Ad break position*\/$/;"	m	class:GlobalConfigAAMP
adURL	priv_aamp.h	/^	const char* adURL;                      \/**< Ad URL*\/$/;"	m	class:GlobalConfigAAMP
adaptationSet	fragmentcollector_mpd.cpp	/^	IAdaptationSet *adaptationSet;$/;"	m	class:MediaStreamContext	file:
adaptationSetId	fragmentcollector_mpd.cpp	/^	uint32_t adaptationSetId;$/;"	m	class:MediaStreamContext	file:
adaptationSetIdx	fragmentcollector_mpd.cpp	/^	int adaptationSetIdx;$/;"	m	class:MediaStreamContext	file:
addtuneEvent	priv_aamp.h	/^	void addtuneEvent(ProfilerBucketType pbt, unsigned int start,$/;"	f	class:ProfileEventAAMP
allowsCache	fragmentcollector_hls.h	/^	bool allowsCache;								\/**< Flag indicating if playlist needs to be cached or not *\/$/;"	m	class:StreamAbstractionAAMP_HLS
analyze_streams	aampgstplayer.cpp	/^static void analyze_streams(AAMPGstPlayer *_this)$/;"	f	file:
anomalyReport	main_aamp.h	/^		} anomalyReport;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon10
appsrc_seek	aampgstplayer.cpp	/^static gboolean  appsrc_seek  (GstAppSrc *src, guint64 offset, AAMPGstPlayer * _this)$/;"	f	file:
associatedLanguage	tsprocessor.h	/^	char *associatedLanguage;$/;"	m	struct:RecordingComponent
audio	fragmentcollector_hls.h	/^	const char *audio;	\/**< Audio *\/$/;"	m	struct:HlsStreamInfo
audioComponentCount	tsprocessor.h	/^      int videoComponentCount, audioComponentCount, dataComponentCount;$/;"	m	class:TSProcessor
audioComponents	tsprocessor.h	/^      RecordingComponent videoComponents[MAX_PIDS], audioComponents[MAX_PIDS], dataComponents[MAX_PIDS];$/;"	m	class:TSProcessor
audioFormatMap	fragmentcollector_hls.cpp	/^static const FormatMap audioFormatMap[AAMP_AUDIO_FORMAT_MAP_LEN] =$/;"	v	file:
audioMuted	aampgstplayer.cpp	/^	bool audioMuted; \/\/Audio mute status.$/;"	m	struct:AAMPGstPlayerPriv	file:
audioVolume	aampgstplayer.cpp	/^	double audioVolume; \/\/Audio volume.$/;"	m	struct:AAMPGstPlayerPriv	file:
audio_dec	aampgstplayer.cpp	/^	GstElement *audio_dec; \/\/Audio decoder used by pipeline.$/;"	m	struct:AAMPGstPlayerPriv	file:
audio_sink	aampgstplayer.cpp	/^	GstElement *audio_sink; \/\/Audio sink used by pipeline.$/;"	m	struct:AAMPGstPlayerPriv	file:
audio_volume	priv_aamp.h	/^	int audio_volume;$/;"	m	class:PrivateInstanceAAMP
autoselect	fragmentcollector_hls.h	/^	bool autoselect;		\/**< AutoSelect *\/$/;"	m	struct:MediaInfo
avail	priv_aamp.h	/^	size_t avail;   \/**< Available buffer size *\/$/;"	m	struct:GrowableBuffer
averageBandwidth	fragmentcollector_hls.h	/^	long averageBandwidth;	\/**< Average Bandwidth *\/$/;"	m	struct:HlsStreamInfo
bAudioOnlyPlayback	priv_aamp.h	/^	bool bAudioOnlyPlayback;                \/**< AAMP Audio Only Playback*\/$/;"	m	class:GlobalConfigAAMP
bEnableABR	priv_aamp.h	/^	bool bEnableABR;            \/**< Enable\/Disable adaptive bitrate logic*\/$/;"	m	class:GlobalConfigAAMP
bEnableCC	priv_aamp.h	/^	bool bEnableCC;             \/**< Enable\/Disable Closed Caption*\/$/;"	m	class:GlobalConfigAAMP
bForceHttp	priv_aamp.h	/^	bool bForceHttp;                        \/**< Force HTTP*\/$/;"	m	class:GlobalConfigAAMP
bandwidthBitsPerSecond	StreamAbstractionAAMP.h	/^	long bandwidthBitsPerSecond;    \/**< Bandwidth of the stream bps*\/$/;"	m	struct:StreamInfo
bandwidthBitsPerSecondAudio	priv_aamp.h	/^	long bandwidthBitsPerSecondAudio;       \/**< Audio bandwidth in bps *\/$/;"	m	class:ProfileEventAAMP
bandwidthBitsPerSecondVideo	priv_aamp.h	/^	long bandwidthBitsPerSecondVideo;       \/**< Video bandwidth in bps *\/$/;"	m	class:ProfileEventAAMP
bandwidthBytesPerSecond	StreamAbstractionAAMP.h	/^	int bandwidthBytesPerSecond;        \/**< Bandwidth of last selected profile*\/$/;"	m	class:MediaTrack
base16_Decode	base16.cpp	/^unsigned char *base16_Decode( const char *srcPtr, size_t srcLen, size_t *len )$/;"	f
base16_Encode	base16.cpp	/^char *base16_Encode(const unsigned char *src, size_t len)$/;"	f
base64_Decode	_base64.cpp	/^unsigned char *base64_Decode(const char *src, size_t *len)$/;"	f
base64_Encode	_base64.cpp	/^char *base64_Encode(const unsigned char *src, size_t len)$/;"	f
baseUrls	fragmentcollector_mpd.cpp	/^	const std::vector<IBaseUrl *>*baseUrls;$/;"	m	struct:FragmentDescriptor	file:
base_pts	tsprocessor.cpp	/^	unsigned long long base_pts;$/;"	m	class:Demuxer	file:
bitrate	main_aamp.h	/^			long bitrate;                \/**< Playback bitrate *\/$/;"	m	struct:AAMPEvent::__anon9::__anon13
bitrateChanged	main_aamp.h	/^		} bitrateChanged;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon13
bitrateCount	main_aamp.h	/^			int bitrateCount;                                               \/**< Available bitrate count *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
bitrates	main_aamp.h	/^			long bitrates[MAX_BITRATE_COUNT];                               \/**< Available bitrates *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
bucketDuration	priv_aamp.h	867;"	d
buckets	priv_aamp.h	/^	} buckets[PROFILE_BUCKET_TYPE_COUNT];$/;"	m	class:ProfileEventAAMP	typeref:struct:ProfileEventAAMP::ProfilerBucket
bucketsOverlap	priv_aamp.h	860;"	d
buffer	main_aamp.cpp	/^	GrowableBuffer *buffer;$/;"	m	struct:CurlCallbackContext	file:
bufferHealthMonitorDelay	priv_aamp.h	/^	int bufferHealthMonitorDelay;           \/**< Buffer health monitor start delay after tune\/ seek*\/$/;"	m	class:GlobalConfigAAMP
bufferHealthMonitorInterval	priv_aamp.h	/^	int bufferHealthMonitorInterval;        \/**< Buffer health monitor interval*\/$/;"	m	class:GlobalConfigAAMP
bufferMonitorThreadID	StreamAbstractionAAMP.h	/^	pthread_t bufferMonitorThreadID;    \/**< Buffer Monitor thread id *\/$/;"	m	class:MediaTrack
bufferMonitorThreadStarted	StreamAbstractionAAMP.h	/^	bool bufferMonitorThreadStarted;    \/**< Buffer Monitor thread started or not *\/$/;"	m	class:MediaTrack
bufferStatus	StreamAbstractionAAMP.h	/^	BufferHealthStatus bufferStatus;     \/**< Buffer status of the track*\/$/;"	m	class:MediaTrack
bufferUnderrun	aampgstplayer.cpp	/^	bool bufferUnderrun;$/;"	m	struct:media_stream	file:
buffering	main_aamp.h	/^			bool buffering;            \/**< true if buffering started, false otherwise *\/$/;"	m	struct:AAMPEvent::__anon9::__anon21
bufferingChanged	main_aamp.h	/^		} bufferingChanged;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon21
buffering_enabled	aampgstplayer.cpp	/^	gboolean buffering_enabled; \/\/ enable buffering based on multiqueue$/;"	m	struct:AAMPGstPlayerPriv	file:
buffering_in_progress	aampgstplayer.cpp	/^	gboolean buffering_in_progress; \/\/ buffering is in progress$/;"	m	struct:AAMPGstPlayerPriv	file:
buffering_target_state	aampgstplayer.cpp	/^	GstState buffering_target_state; \/\/ the target state after buffering$/;"	m	struct:AAMPGstPlayerPriv	file:
buffering_timeout	aampgstplayer.cpp	/^static gboolean buffering_timeout (gpointer data)$/;"	f	file:
buffering_timeout_cnt	aampgstplayer.cpp	/^	guint buffering_timeout_cnt;    \/\/ make sure buffering_timout doesn't get stuck$/;"	m	struct:AAMPGstPlayerPriv	file:
bus	aampgstplayer.cpp	/^	GstBus *bus; \/\/Bus for receiving GstEvents from pipeline.$/;"	m	struct:AAMPGstPlayerPriv	file:
busWatchId	aampgstplayer.cpp	/^	guint busWatchId;$/;"	m	struct:AAMPGstPlayerPriv	file:
bus_message	aampgstplayer.cpp	/^static gboolean bus_message(GstBus * bus, GstMessage * msg, AAMPGstPlayer * _this)$/;"	f	file:
bus_sync_handler	aampgstplayer.cpp	/^static GstBusSyncReply bus_sync_handler(GstBus * bus, GstMessage * msg, AAMPGstPlayer * _this)$/;"	f	file:
byteRangeLength	fragmentcollector_hls.h	/^	int byteRangeLength; \/**< state for \\#EXT-X-BYTERANGE fragments *\/$/;"	m	class:TrackState
byteRangeOffset	fragmentcollector_hls.h	/^	int byteRangeOffset; \/**< state for \\#EXT-X-BYTERANGE fragments *\/$/;"	m	class:TrackState
cacheDurationSeconds	StreamAbstractionAAMP.h	/^	int cacheDurationSeconds;           \/**< Total fragment cache duration*\/$/;"	m	class:MediaTrack
cachedFragment	StreamAbstractionAAMP.h	/^	CachedFragment *cachedFragment;     \/**< storage for currently-downloaded fragment *\/$/;"	m	class:MediaTrack
ccHandle	main_aamp.h	/^		} ccHandle;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon15
cdvrliveOffset	priv_aamp.h	/^	int cdvrliveOffset;                     \/**< CDVR LIVE offset*\/$/;"	m	class:GlobalConfigAAMP
channels	fragmentcollector_hls.h	/^	int channels;			\/**< Channel *\/$/;"	m	struct:MediaInfo
checkIfInterlaced	tsprocessor.cpp	/^void TSProcessor::checkIfInterlaced(unsigned char *packet, int length)$/;"	f	class:TSProcessor
closedCaptions	fragmentcollector_hls.h	/^	const char *closedCaptions;	\/**< CC if present *\/$/;"	m	struct:HlsStreamInfo
code	main_aamp.h	/^			int code;                                           \/**< Error code *\/$/;"	m	struct:AAMPEvent::__anon9::__anon18
code	main_aamp.h	/^	int code;                       \/**< Error code *\/$/;"	m	struct:TuneFailureMap
code	tsprocessor.cpp	/^	int code;$/;"	m	struct:MBAddrIncCode	file:
codec	fragmentcollector_hls.cpp	/^	const char* codec;$/;"	m	struct:FormatMap	file:
codecs	fragmentcollector_hls.h	/^	const char *codecs;	\/**< Codec String *\/$/;"	m	struct:HlsStreamInfo
complete	priv_aamp.h	/^		bool complete;          \/**< true if this step already accounted for, and further profiling should be ignored *\/$/;"	m	struct:ProfileEventAAMP::ProfilerBucket
completionTimeSecondsFromStart	fragmentcollector_hls.h	/^	double completionTimeSecondsFromStart;	\/**< Time of index from start *\/$/;"	m	struct:IndexNode
contentMetadata	fragmentcollector_mpd.cpp	/^	unsigned char *contentMetadata;$/;"	m	struct:DrmSessionParams	file:
context	fragmentcollector_hls.h	/^	StreamAbstractionAAMP_HLS* context; \/**< To get  settings common across tracks*\/$/;"	m	class:TrackState
context	fragmentcollector_mpd.cpp	/^	class PrivateStreamAbstractionMPD *context;$/;"	m	struct:FragmentDownloadParams	typeref:class:FragmentDownloadParams::PrivateStreamAbstractionMPD	file:
context	fragmentcollector_mpd.cpp	/^	class PrivateStreamAbstractionMPD *context;$/;"	m	struct:HeaderFetchParams	typeref:class:HeaderFetchParams::PrivateStreamAbstractionMPD	file:
crc32_initialized	tsprocessor.cpp	/^static int crc32_initialized = 0;$/;"	v	file:
crc32_table	tsprocessor.cpp	/^static unsigned long crc32_table[256];$/;"	v	file:
createDRMSessionThreadID	fragmentcollector_mpd.cpp	/^	pthread_t createDRMSessionThreadID;$/;"	m	class:PrivateStreamAbstractionMPD	file:
createNullPFrame	tsprocessor.cpp	/^unsigned char* TSProcessor::createNullPFrame(int width, int height, int *nullPFrameLen)$/;"	f	class:TSProcessor
culledSeconds	priv_aamp.h	/^	double culledSeconds;$/;"	m	class:PrivateInstanceAAMP
curl	priv_aamp.h	/^	CURL *curl[MAX_CURL_INSTANCE_COUNT];$/;"	m	class:PrivateInstanceAAMP
curl	priv_aamp.h	/^	bool curl;       \/**< Curl logs*\/$/;"	m	class:AampLogManager
curlLowSpeedLimit	priv_aamp.h	/^	long curlLowSpeedLimit;                 \/**< Value to be used for CURLOPT_LOW_SPEED_LIMIT in bytes\/sec*\/$/;"	m	class:GlobalConfigAAMP
curlLowSpeedTime	priv_aamp.h	/^	long curlLowSpeedTime;                  \/**< Value to be used for CURLOPT_LOW_SPEED_TIME in seconds*\/$/;"	m	class:GlobalConfigAAMP
currentBandwidth	priv_aamp.h	/^	long currentBandwidth;$/;"	m	struct:AAMPAbrInfo
currentIdx	fragmentcollector_hls.h	/^	int currentIdx; 				\/**< index for currently-presenting fragment used during FF\/REW (-1 if undefined) *\/$/;"	m	class:TrackState
currentProfileIndex	StreamAbstractionAAMP.h	/^	int currentProfileIndex;                \/**< current profile index of the track*\/$/;"	m	class:StreamAbstractionAAMP
currentProfileIndex	priv_aamp.h	/^	int currentProfileIndex;$/;"	m	struct:AAMPAbrInfo
current_audio	aampgstplayer.cpp	/^	gint current_audio; \/\/Offset of current audio track.$/;"	m	struct:AAMPGstPlayerPriv	file:
current_dts	tsprocessor.cpp	/^	unsigned long long current_dts;$/;"	m	class:Demuxer	file:
current_pts	tsprocessor.cpp	/^	unsigned long long current_pts;$/;"	m	class:Demuxer	file:
current_rate	aampgstplayer.cpp	/^	int current_rate; $/;"	m	struct:AAMPGstPlayerPriv	file:
dashIgnoreBaseURLIfSlash	priv_aamp.h	/^	bool dashIgnoreBaseURLIfSlash;          \/**< Ignore the constructed URI of DASH, if it is \/ *\/$/;"	m	class:GlobalConfigAAMP
dash_drmmetadata	main_aamp.h	/^		} dash_drmmetadata;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon19
data	main_aamp.h	/^	} data;$/;"	m	struct:AAMPEvent	typeref:union:AAMPEvent::__anon9
data	priv_aamp.h	/^	    char data[1];$/;"	m	struct:PrivateInstanceAAMP::_AAMP2ReceiverMsg
data	priv_aamp.h	/^	std::string data;     \/**< Header value *\/$/;"	m	struct:httpRespHeaderData
dataComponentCount	tsprocessor.h	/^      int videoComponentCount, audioComponentCount, dataComponentCount;$/;"	m	class:TSProcessor
dataComponents	tsprocessor.h	/^      RecordingComponent videoComponents[MAX_PIDS], audioComponents[MAX_PIDS], dataComponents[MAX_PIDS];$/;"	m	class:TSProcessor
debug	priv_aamp.h	/^	bool debug;      \/**< Debug logs*\/$/;"	m	class:AampLogManager
decoderHandleNotified	aampgstplayer.cpp	/^	bool decoderHandleNotified; \/\/Flag that denotes if decoder handle was notified.$/;"	m	struct:AAMPGstPlayerPriv	file:
defaultBitrate	priv_aamp.h	/^	long defaultBitrate;        \/**< Default bitrate*\/$/;"	m	class:GlobalConfigAAMP
defaultBitrate4K	priv_aamp.h	/^	long defaultBitrate4K;      \/**< Default 4K bitrate*\/$/;"	m	class:GlobalConfigAAMP
demuxAndSend	tsprocessor.cpp	/^bool TSProcessor::demuxAndSend(const void *ptr, size_t len, double position, double duration, bool discontinuous, TrackToDemux trackToDemux)$/;"	f	class:TSProcessor
demuxHLSVideoTsTrackTM	priv_aamp.h	/^	int demuxHLSVideoTsTrackTM;             \/**< Demux video track from HLS transport stream track mode*\/$/;"	m	class:GlobalConfigAAMP
demuxedAudioBeforeVideo	priv_aamp.h	/^	int demuxedAudioBeforeVideo;            \/**< Send demuxed audio before video*\/$/;"	m	class:GlobalConfigAAMP
description	main_aamp.h	/^			char description[128];      \/**< Description *\/$/;"	m	struct:AAMPEvent::__anon9::__anon13
description	main_aamp.h	/^			char description[MAX_ERROR_DESCRIPTION_LENGTH];     \/**< Error description *\/$/;"	m	struct:AAMPEvent::__anon9::__anon18
description	main_aamp.h	/^	const char* description;        \/**< Textual description *\/$/;"	m	struct:TuneFailureMap
descriptorTags	tsprocessor.h	/^	unsigned int descriptorTags;$/;"	m	struct:RecordingComponent
desiredBandwidth	priv_aamp.h	/^	long desiredBandwidth;$/;"	m	struct:AAMPAbrInfo
desiredProfileIndex	priv_aamp.h	/^	int desiredProfileIndex;$/;"	m	struct:AAMPAbrInfo
disableATMOS	priv_aamp.h	/^	int disableATMOS;                       \/**< Disable Dolby ATMOS*\/$/;"	m	class:GlobalConfigAAMP
disableEC3	priv_aamp.h	/^	int disableEC3;                         \/**< Disable DDPlus*\/$/;"	m	class:GlobalConfigAAMP
disableLogRedirection	aamplogging.cpp	/^bool AampLogManager::disableLogRedirection = false;$/;"	m	class:AampLogManager	file:
disableLogRedirection	priv_aamp.h	/^	static bool disableLogRedirection;$/;"	m	class:AampLogManager
disablePlaylistIndexEvent	priv_aamp.h	/^	int disablePlaylistIndexEvent;          \/**< Disable playlist index event*\/$/;"	m	class:GlobalConfigAAMP
discardEnteringLiveEvt	priv_aamp.h	/^	bool discardEnteringLiveEvt;$/;"	m	class:PrivateInstanceAAMP
discontinuity	StreamAbstractionAAMP.h	/^	bool discontinuity;         \/**< PTS discontinuity status *\/$/;"	m	struct:CachedFragment
discontinuity	fragmentcollector_hls.h	/^	bool discontinuity; \/**< Set when discontinuity is found in track*\/$/;"	m	class:TrackState
discontinuity	fragmentcollector_mpd.cpp	/^	bool discontinuity;$/;"	m	struct:HeaderFetchParams	file:
discontinuityProcessed	StreamAbstractionAAMP.h	/^	bool discontinuityProcessed;$/;"	m	class:MediaTrack
drmErrorCode	priv_aamp.h	/^	int drmErrorCode;                       \/**< DRM error code *\/$/;"	m	class:ProfileEventAAMP
drmMetadataIdx	fragmentcollector_hls.h	/^	int drmMetadataIdx;						\/**< DRM Index for Fragment *\/$/;"	m	struct:IndexNode
drmSessionThreadStarted	fragmentcollector_mpd.cpp	/^	bool drmSessionThreadStarted;$/;"	m	class:PrivateStreamAbstractionMPD	file:
dumpPacket	tsprocessor.cpp	/^static void dumpPacket(unsigned char *packet, int packetSize)$/;"	f	file:
dumpPackets	tsprocessor.cpp	/^static void dumpPackets(unsigned char *packets, int len, int packetSize)$/;"	f	file:
duration	StreamAbstractionAAMP.h	/^	double duration;            \/**< Fragment duration *\/$/;"	m	struct:CachedFragment
duration	fragmentcollector_mpd.cpp	/^	double duration;$/;"	m	struct:PeriodInfo	file:
duration	priv_aamp.h	/^		unsigned int duration;      \/**< Event duration *\/$/;"	m	class:ProfileEventAAMP::TuneEvent
duration	tsprocessor.cpp	/^	double duration;$/;"	m	class:Demuxer	file:
durationMiliseconds	main_aamp.h	/^			double durationMiliseconds; \/**< current size of time shift buffer *\/$/;"	m	struct:AAMPEvent::__anon9::__anon11
durationMiliseconds	main_aamp.h	/^			long durationMiliseconds;                                       \/**< Asset duration *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
durationSeconds	priv_aamp.h	/^	double durationSeconds;$/;"	m	class:PrivateInstanceAAMP
eAAMPSTATUS_GENERIC_ERROR	priv_aamp.h	/^	eAAMPSTATUS_GENERIC_ERROR,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_MANIFEST_CONTENT_ERROR	priv_aamp.h	/^	eAAMPSTATUS_MANIFEST_CONTENT_ERROR,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_MANIFEST_DOWNLOAD_ERROR	priv_aamp.h	/^	eAAMPSTATUS_MANIFEST_DOWNLOAD_ERROR,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_MANIFEST_PARSE_ERROR	priv_aamp.h	/^	eAAMPSTATUS_MANIFEST_PARSE_ERROR,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_OK	priv_aamp.h	/^	eAAMPSTATUS_OK,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_SEEK_RANGE_ERROR	priv_aamp.h	/^	eAAMPSTATUS_SEEK_RANGE_ERROR,$/;"	e	enum:AAMPStatusType
eAAMPSTATUS_TRACKS_SYNCHRONISATION_ERROR	priv_aamp.h	/^	eAAMPSTATUS_TRACKS_SYNCHRONISATION_ERROR$/;"	e	enum:AAMPStatusType
eAUDIO_AAC	priv_aamp.h	/^	eAUDIO_AAC,$/;"	e	enum:AudioType
eAUDIO_ATMOS	priv_aamp.h	/^	eAUDIO_ATMOS$/;"	e	enum:AudioType
eAUDIO_DDPLUS	priv_aamp.h	/^	eAUDIO_DDPLUS,$/;"	e	enum:AudioType
eAUDIO_UNKNOWN	priv_aamp.h	/^	eAUDIO_UNKNOWN,$/;"	e	enum:AudioType
eAUTHTOKEN_INVALID_STATUS_CODE	main_aamp.h	/^	eAUTHTOKEN_INVALID_STATUS_CODE = -2$/;"	e	enum:AuthTokenErrors
eAUTHTOKEN_TOKEN_PARSE_ERROR	main_aamp.h	/^	eAUTHTOKEN_TOKEN_PARSE_ERROR = -1,$/;"	e	enum:AuthTokenErrors
eDASH_ERROR_STARTTIME_RESET	priv_aamp.h	/^	eDASH_ERROR_STARTTIME_RESET     \/**< Start time reset of DASH *\/$/;"	e	enum:PlaybackErrorType
eDRM_Adobe_Access	main_aamp.h	/^	eDRM_Adobe_Access,      \/**< Adobe Access *\/$/;"	e	enum:DRMSystems
eDRM_CONSEC_agnostic	main_aamp.h	/^	eDRM_CONSEC_agnostic,   \/**< CONSEC Agnostic DRM *\/$/;"	e	enum:DRMSystems
eDRM_MAX_DRMSystems	main_aamp.h	/^	eDRM_MAX_DRMSystems     \/**< Drm system count *\/$/;"	e	enum:DRMSystems
eDRM_NONE	main_aamp.h	/^	eDRM_NONE,              \/**< No DRM *\/$/;"	e	enum:DRMSystems
eDRM_PlayReady	main_aamp.h	/^	eDRM_PlayReady,         \/**< Playready *\/$/;"	e	enum:DRMSystems
eDRM_Vanilla_AES	main_aamp.h	/^	eDRM_Vanilla_AES,       \/**< Vanilla AES *\/$/;"	e	enum:DRMSystems
eDRM_WideVine	main_aamp.h	/^	eDRM_WideVine,          \/**< Widevine *\/$/;"	e	enum:DRMSystems
eGST_ERROR_PTS	priv_aamp.h	/^	eGST_ERROR_PTS,                 \/**< PTS error from gstreamer *\/$/;"	e	enum:PlaybackErrorType
eGST_ERROR_UNDERFLOW	priv_aamp.h	/^	eGST_ERROR_UNDERFLOW,           \/**< Underflow error from gstreamer *\/$/;"	e	enum:PlaybackErrorType
eHTTPHEADERTYPE_COOKIE	priv_aamp.h	/^	eHTTPHEADERTYPE_COOKIE,     \/**< Cookie Header *\/$/;"	e	enum:HttpHeaderType
eHTTPHEADERTYPE_FOG_REASON	priv_aamp.h	/^	eHTTPHEADERTYPE_FOG_REASON,    \/**< X-Reason Header *\/$/;"	e	enum:HttpHeaderType
eHTTPHEADERTYPE_UNKNOWN	priv_aamp.h	/^	eHTTPHEADERTYPE_UNKNOWN=-1  \/**< Unkown Header *\/$/;"	e	enum:HttpHeaderType
eHTTPHEADERTYPE_XREASON	priv_aamp.h	/^	eHTTPHEADERTYPE_XREASON,    \/**< X-Reason Header *\/$/;"	e	enum:HttpHeaderType
eLOGLEVEL_ERROR	priv_aamp.h	/^	eLOGLEVEL_ERROR     \/**< Error level *\/$/;"	e	enum:AAMP_LogLevel
eLOGLEVEL_INFO	priv_aamp.h	/^	eLOGLEVEL_INFO,     \/**< Info level *\/$/;"	e	enum:AAMP_LogLevel
eLOGLEVEL_TRACE	priv_aamp.h	/^	eLOGLEVEL_TRACE,    \/**< Trace level *\/$/;"	e	enum:AAMP_LogLevel
eLOGLEVEL_WARN	priv_aamp.h	/^	eLOGLEVEL_WARN,     \/**< Warn level *\/$/;"	e	enum:AAMP_LogLevel
eMEDIATYPE_AUDIO	main_aamp.h	/^	eMEDIATYPE_AUDIO,               \/**< Type audio *\/$/;"	e	enum:MediaType
eMEDIATYPE_DEFAULT	main_aamp.h	/^	eMEDIATYPE_DEFAULT              \/**< Type unknown *\/$/;"	e	enum:MediaType
eMEDIATYPE_IFRAME	main_aamp.h	/^	eMEDIATYPE_IFRAME,              \/**< Type iframe *\/$/;"	e	enum:MediaType
eMEDIATYPE_INIT_AUDIO	main_aamp.h	/^	eMEDIATYPE_INIT_AUDIO,          \/**< Type audio init fragment *\/$/;"	e	enum:MediaType
eMEDIATYPE_INIT_VIDEO	main_aamp.h	/^	eMEDIATYPE_INIT_VIDEO,          \/**< Type video init fragment *\/$/;"	e	enum:MediaType
eMEDIATYPE_LICENCE	main_aamp.h	/^	eMEDIATYPE_LICENCE,             \/**< Type license *\/$/;"	e	enum:MediaType
eMEDIATYPE_MANIFEST	main_aamp.h	/^	eMEDIATYPE_MANIFEST,            \/**< Type manifest *\/$/;"	e	enum:MediaType
eMEDIATYPE_PLAYLIST_AUDIO	main_aamp.h	/^	eMEDIATYPE_PLAYLIST_AUDIO,      \/**< Type audio playlist *\/$/;"	e	enum:MediaType
eMEDIATYPE_PLAYLIST_VIDEO	main_aamp.h	/^	eMEDIATYPE_PLAYLIST_VIDEO,      \/**< Type video playlist *\/$/;"	e	enum:MediaType
eMEDIATYPE_VIDEO	main_aamp.h	/^	eMEDIATYPE_VIDEO,               \/**< Type video *\/$/;"	e	enum:MediaType
ePC_Track_Audio	tsprocessor.h	/^	ePC_Track_Audio,$/;"	e	enum:__anon26
ePC_Track_Both	tsprocessor.h	/^	ePC_Track_Both$/;"	e	enum:__anon26
ePC_Track_Video	tsprocessor.h	/^	ePC_Track_Video,$/;"	e	enum:__anon26
ePLAYLISTTYPE_EVENT	StreamAbstractionAAMP.h	/^	ePLAYLISTTYPE_EVENT,        \/**< Playlist may grow via appended lines, but otherwise won't change *\/$/;"	e	enum:__anon2
ePLAYLISTTYPE_UNDEFINED	StreamAbstractionAAMP.h	/^	ePLAYLISTTYPE_UNDEFINED,    \/**< Playlist type undefined *\/$/;"	e	enum:__anon2
ePLAYLISTTYPE_VOD	StreamAbstractionAAMP.h	/^	ePLAYLISTTYPE_VOD,          \/**< Playlist will never change *\/$/;"	e	enum:__anon2
eSTATE_BUFFERING	main_aamp.h	/^	eSTATE_BUFFERING,    \/**< 5  - Player is in buffering state *\/$/;"	e	enum:__anon8
eSTATE_COMPLETE	main_aamp.h	/^	eSTATE_COMPLETE,     \/**< 11 - Playback completed *\/$/;"	e	enum:__anon8
eSTATE_ERROR	main_aamp.h	/^	eSTATE_ERROR,        \/**< 12 - Error encountered and playback stopped *\/$/;"	e	enum:__anon8
eSTATE_IDLE	main_aamp.h	/^	eSTATE_IDLE,         \/**< 0  - Player is idle *\/$/;"	e	enum:__anon8
eSTATE_INITIALIZED	main_aamp.h	/^	eSTATE_INITIALIZED,  \/**< 2  - Player has initialized for a content successfully *\/$/;"	e	enum:__anon8
eSTATE_INITIALIZING	main_aamp.h	/^	eSTATE_INITIALIZING, \/**< 1  - Player is initializing a particular content *\/$/;"	e	enum:__anon8
eSTATE_PAUSED	main_aamp.h	/^	eSTATE_PAUSED,       \/**< 6  - Playback is paused *\/$/;"	e	enum:__anon8
eSTATE_PLAYING	main_aamp.h	/^	eSTATE_PLAYING,      \/**< 8  - Playback is in progress *\/$/;"	e	enum:__anon8
eSTATE_PREPARED	main_aamp.h	/^	eSTATE_PREPARED,     \/**< 4  - Player has loaded all associated resources successfully *\/$/;"	e	enum:__anon8
eSTATE_PREPARING	main_aamp.h	/^	eSTATE_PREPARING,    \/**< 3  - Player is loading all associated resources *\/$/;"	e	enum:__anon8
eSTATE_RELEASED	main_aamp.h	/^	eSTATE_RELEASED      \/**< 13 - Player has released all resources for playback *\/$/;"	e	enum:__anon8
eSTATE_SEEKING	main_aamp.h	/^	eSTATE_SEEKING,      \/**< 7  - Seek is in progress *\/$/;"	e	enum:__anon8
eSTATE_STOPPED	main_aamp.h	/^	eSTATE_STOPPED,      \/**< 10 - Player has stopped playback successfully *\/$/;"	e	enum:__anon8
eSTATE_STOPPING	main_aamp.h	/^	eSTATE_STOPPING,     \/**< 9  - Player is stopping the playback *\/$/;"	e	enum:__anon8
eStreamOp_DEMUX_ALL	tsprocessor.h	/^	eStreamOp_DEMUX_ALL,$/;"	e	enum:__anon25
eStreamOp_DEMUX_AUDIO	tsprocessor.h	/^	eStreamOp_DEMUX_AUDIO,$/;"	e	enum:__anon25
eStreamOp_DEMUX_VIDEO	tsprocessor.h	/^	eStreamOp_DEMUX_VIDEO,$/;"	e	enum:__anon25
eStreamOp_NONE	tsprocessor.h	/^	eStreamOp_NONE,$/;"	e	enum:__anon25
eStreamOp_QUEUE_AUDIO	tsprocessor.h	/^	eStreamOp_QUEUE_AUDIO,$/;"	e	enum:__anon25
eStreamOp_SEND_VIDEO_AND_QUEUED_AUDIO	tsprocessor.h	/^	eStreamOp_SEND_VIDEO_AND_QUEUED_AUDIO$/;"	e	enum:__anon25
eTRACK_AUDIO	StreamAbstractionAAMP.h	/^	eTRACK_AUDIO    \/**< Audio track *\/$/;"	e	enum:__anon1
eTRACK_VIDEO	StreamAbstractionAAMP.h	/^	eTRACK_VIDEO,   \/**< Video track *\/$/;"	e	enum:__anon1
eTUNED_EVENT_MAX	priv_aamp.h	/^        eTUNED_EVENT_MAX$/;"	e	enum:TunedEventConfig
eTUNED_EVENT_ON_FIRST_FRAGMENT_DECRYPTED	priv_aamp.h	/^	eTUNED_EVENT_ON_FIRST_FRAGMENT_DECRYPTED,    \/**< Send TUNED event after first fragment decryption*\/$/;"	e	enum:TunedEventConfig
eTUNED_EVENT_ON_GST_PLAYING	priv_aamp.h	/^	eTUNED_EVENT_ON_GST_PLAYING,                \/**< Send TUNED event on gstreamer's playing event*\/$/;"	e	enum:TunedEventConfig
eTUNED_EVENT_ON_PLAYLIST_INDEXED	priv_aamp.h	/^	eTUNED_EVENT_ON_PLAYLIST_INDEXED,           \/**< Send TUNED event after playlist indexed*\/$/;"	e	enum:TunedEventConfig
eTUNETYPE_LAST	priv_aamp.h	/^	eTUNETYPE_LAST          \/**< Use the tune mode used in last tune*\/$/;"	e	enum:TuneType
eTUNETYPE_NEW_NORMAL	priv_aamp.h	/^	eTUNETYPE_NEW_NORMAL,   \/**< Play from live point for live streams, from start for VOD*\/$/;"	e	enum:TuneType
eTUNETYPE_NEW_SEEK	priv_aamp.h	/^	eTUNETYPE_NEW_SEEK,     \/**< A new tune with valid seek position*\/$/;"	e	enum:TuneType
eTUNETYPE_RETUNE	priv_aamp.h	/^	eTUNETYPE_RETUNE,       \/**< Internal retune for error handling.*\/$/;"	e	enum:TuneType
eTUNETYPE_SEEK	priv_aamp.h	/^	eTUNETYPE_SEEK,         \/**< Seek to a position. Not a new channel, so resources can be reused*\/$/;"	e	enum:TuneType
eTUNETYPE_SEEKTOLIVE	priv_aamp.h	/^	eTUNETYPE_SEEKTOLIVE,   \/**< Seek to live point. Not a new channel, so resources can be reused*\/$/;"	e	enum:TuneType
eas_curl_debug_callback	main_aamp.cpp	/^static int eas_curl_debug_callback(CURL *handle, curl_infotype type, char *data, size_t size, void *userp)$/;"	f	file:
effectiveBucketTime	priv_aamp.h	/^	inline unsigned int effectiveBucketTime(ProfilerBucketType id1, ProfilerBucketType id2)$/;"	f	class:ProfileEventAAMP
effectiveUrl	fragmentcollector_hls.h	/^	char effectiveUrl[MAX_URI_LENGTH]; 		\/**< uri associated with downloaded playlist (takes into account 302 redirect) *\/$/;"	m	class:TrackState
elemStreamType	tsprocessor.h	/^	int elemStreamType;$/;"	m	struct:RecordingComponent
enableMicroEvents	priv_aamp.h	/^	bool enableMicroEvents;                 \/**< Enabling the tunetime micro events*\/$/;"	m	class:GlobalConfigAAMP
enableSubscribedTags	priv_aamp.h	/^	int enableSubscribedTags;               \/**< Enabled subscribed tags*\/$/;"	m	class:GlobalConfigAAMP
enableThrottle	fragmentcollector_hls.h	/^	bool enableThrottle;							\/**< Flag indicating throttle enable\/disable *\/$/;"	m	class:StreamAbstractionAAMP_HLS
enabled	StreamAbstractionAAMP.h	/^	bool enabled;                       \/**< set to true if track is enabled *\/$/;"	m	class:MediaTrack
enabled	priv_aamp.h	/^	bool enabled;                           \/**< Profiler started or not *\/$/;"	m	class:ProfileEventAAMP
endMiliseconds	main_aamp.h	/^			double endMiliseconds;      \/**< time shift buffer end position (relative to tune time - starts at zero) *\/$/;"	m	struct:AAMPEvent::__anon9::__anon11
endTimeReached	fragmentcollector_mpd.cpp	/^	bool endTimeReached;$/;"	m	class:MediaStreamContext	file:
enough_data	aampgstplayer.cpp	/^static void enough_data(GstElement *source, AAMPGstPlayer * _this)$/;"	f	file:
eos	fragmentcollector_mpd.cpp	/^	bool eos;$/;"	m	class:MediaStreamContext	file:
eosCallbackIdleTaskId	aampgstplayer.cpp	/^	guint eosCallbackIdleTaskId; \/\/ID of idle handler created for notifying EOS event.$/;"	m	struct:AAMPGstPlayerPriv	file:
eosCallbackIdleTaskPending	aampgstplayer.cpp	/^	std::atomic<bool> eosCallbackIdleTaskPending; \/\/Set if any eos callback is pending.$/;"	m	struct:AAMPGstPlayerPriv	file:
eosReached	StreamAbstractionAAMP.h	/^	bool eosReached;                    \/**< set to true when a vod asset has been played to completion *\/$/;"	m	class:MediaTrack
eosReached	aampgstplayer.cpp	/^	bool eosReached;$/;"	m	struct:media_stream	file:
eosSignalled	aampgstplayer.cpp	/^	std::atomic<bool> eosSignalled; \/** Indicates if EOS has signaled *\/$/;"	m	struct:AAMPGstPlayerPriv	file:
errorCode	priv_aamp.h	/^	int errorCode;$/;"	m	struct:AAMPAbrInfo
errorCount	priv_aamp.h	/^		int errorCount;         \/**< non-zero if errors\/retries occured during this operation *\/$/;"	m	struct:ProfileEventAAMP::ProfilerBucket
errorType	priv_aamp.h	/^	AAMPNetworkErrorType errorType;$/;"	m	struct:AAMPAbrInfo
es	tsprocessor.cpp	/^	GrowableBuffer es;$/;"	m	class:Demuxer	file:
event	main_aamp.cpp	/^	AAMPEvent event;$/;"	m	struct:AsyncEventDescriptor	file:
eventListener	priv_aamp.h	/^	AAMPEventListener* eventListener;   \/**< Event listener *\/$/;"	m	struct:ListenerData
failover	priv_aamp.h	/^	bool failover;	 \/**< server fail over logs*\/$/;"	m	class:AampLogManager
failure	main_aamp.h	/^			AAMPTuneFailure failure;                            \/**< Error Type *\/$/;"	m	struct:AAMPEvent::__anon9::__anon18
failure	main_aamp.h	/^			AAMPTuneFailure failure;                            \/**< Error Type *\/$/;"	m	struct:AAMPEvent::__anon9::__anon19
finalized_base_pts	tsprocessor.cpp	/^	bool finalized_base_pts;$/;"	m	class:Demuxer	file:
firstFragmentDecrypted	fragmentcollector_hls.h	/^	bool firstFragmentDecrypted;					\/**< Flag indicating if first fragment is decrypted for stream *\/$/;"	m	class:StreamAbstractionAAMP_HLS
firstFrameCallbackIdleTaskId	aampgstplayer.cpp	/^	guint firstFrameCallbackIdleTaskId; \/\/ID of idle handler created for notifying first frame event.$/;"	m	struct:AAMPGstPlayerPriv	file:
firstFrameCallbackIdleTaskPending	aampgstplayer.cpp	/^	std::atomic<bool> firstFrameCallbackIdleTaskPending; \/\/Set if any first frame callback is pending.$/;"	m	struct:AAMPGstPlayerPriv	file:
firstFrameReceived	aampgstplayer.cpp	/^	bool firstFrameReceived; \/\/Flag that denotes if first frame was notified.$/;"	m	struct:AAMPGstPlayerPriv	file:
firstIndexDone	fragmentcollector_hls.h	/^	bool firstIndexDone;                    \/**< Indicates if first indexing is done*\/$/;"	m	class:TrackState
firstProgressCallbackIdleTaskId	aampgstplayer.cpp	/^	guint firstProgressCallbackIdleTaskId; \/\/ID of idle handler created for notifying first progress event.$/;"	m	struct:AAMPGstPlayerPriv	file:
firstProgressCallbackIdleTaskPending	aampgstplayer.cpp	/^	std::atomic<bool> firstProgressCallbackIdleTaskPending; \/\/Set if any first progress callback is pending.$/;"	m	struct:AAMPGstPlayerPriv	file:
flush	aampgstplayer.cpp	/^	bool flush;$/;"	m	struct:media_stream	file:
flush	tsprocessor.cpp	/^	void flush()$/;"	f	class:Demuxer
flush	tsprocessor.cpp	/^void TSProcessor::flush()$/;"	f	class:TSProcessor
fogSupportsDash	priv_aamp.h	/^	bool fogSupportsDash;       \/**< Enable FOG support for DASH*\/$/;"	m	class:GlobalConfigAAMP
forceEC3	priv_aamp.h	/^	int forceEC3;                           \/**< Forcefully enable DDPlus*\/$/;"	m	class:GlobalConfigAAMP
forced	fragmentcollector_hls.h	/^	bool forced;			\/**< Forced Flag *\/$/;"	m	struct:MediaInfo
format	aampgstplayer.cpp	/^	StreamOutputFormat format;$/;"	m	struct:media_stream	file:
format	fragmentcollector_hls.cpp	/^	StreamOutputFormat format;$/;"	m	struct:FormatMap	file:
found_source	aampgstplayer.cpp	/^static void found_source(GObject * object, GObject * orig, GParamSpec * pspec, AAMPGstPlayer * _this )$/;"	f	file:
fragment	StreamAbstractionAAMP.h	/^	GrowableBuffer fragment;    \/**< Buffer to keep fragment content *\/$/;"	m	struct:CachedFragment
fragmentCollectorThreadID	fragmentcollector_hls.h	/^	pthread_t fragmentCollectorThreadID;	\/**< Thread Id for Fragment  collector Thread *\/$/;"	m	class:TrackState
fragmentCollectorThreadID	fragmentcollector_mpd.cpp	/^	pthread_t fragmentCollectorThreadID;$/;"	m	class:PrivateStreamAbstractionMPD	file:
fragmentCollectorThreadID	priv_aamp.h	/^	pthread_t fragmentCollectorThreadID;$/;"	m	class:PrivateInstanceAAMP
fragmentCollectorThreadStarted	fragmentcollector_hls.h	/^	bool fragmentCollectorThreadStarted;	\/**< Flag indicating if fragment collector thread started or not*\/$/;"	m	class:TrackState
fragmentCollectorThreadStarted	fragmentcollector_mpd.cpp	/^	bool fragmentCollectorThreadStarted;$/;"	m	class:PrivateStreamAbstractionMPD	file:
fragmentDLTimeout	priv_aamp.h	/^	long fragmentDLTimeout;                 \/**< Fragment download timeout*\/$/;"	m	class:GlobalConfigAAMP
fragmentDescriptor	fragmentcollector_mpd.cpp	/^	struct FragmentDescriptor fragmentDescriptor;$/;"	m	class:MediaStreamContext	typeref:struct:MediaStreamContext::FragmentDescriptor	file:
fragmentDurationSeconds	StreamAbstractionAAMP.h	/^	double fragmentDurationSeconds;     \/**< duration in seconds for current fragment-of-interest *\/$/;"	m	class:MediaTrack
fragmentEncrypted	fragmentcollector_hls.h	/^	bool fragmentEncrypted; \/**< In DAI, ad fragments can be clear. Set if current fragment is encrypted*\/$/;"	m	class:TrackState
fragmentFetched	StreamAbstractionAAMP.h	/^	pthread_cond_t fragmentFetched;     \/**< Signaled after a fragment is fetched*\/$/;"	m	class:MediaTrack
fragmentIdx	fragmentcollector_hls.h	/^	int fragmentIdx;	         \/**< Idx of fragment in index table*\/$/;"	m	struct:DiscontinuityIndexNode
fragmentIdxToFetch	StreamAbstractionAAMP.h	/^	int fragmentIdxToFetch;             \/**< Read position *\/$/;"	m	class:MediaTrack
fragmentIdxToInject	StreamAbstractionAAMP.h	/^	int fragmentIdxToInject;            \/**< Write position *\/$/;"	m	class:MediaTrack
fragmentIndex	fragmentcollector_mpd.cpp	/^	int fragmentIndex;$/;"	m	class:MediaStreamContext	file:
fragmentInjected	StreamAbstractionAAMP.h	/^	pthread_cond_t fragmentInjected;    \/**< Signaled after a fragment is injected*\/$/;"	m	class:MediaTrack
fragmentInjectorThreadID	StreamAbstractionAAMP.h	/^	pthread_t fragmentInjectorThreadID; \/**< Fragment injector thread id*\/$/;"	m	class:MediaTrack
fragmentInjectorThreadStarted	StreamAbstractionAAMP.h	/^	bool fragmentInjectorThreadStarted; \/**< Fragment injector's thread started or not*\/$/;"	m	class:MediaTrack
fragmentOffset	fragmentcollector_mpd.cpp	/^	int fragmentOffset;$/;"	m	class:MediaStreamContext	file:
fragmentRepeatCount	fragmentcollector_mpd.cpp	/^	int fragmentRepeatCount;$/;"	m	class:MediaStreamContext	file:
fragmentTime	fragmentcollector_mpd.cpp	/^	double fragmentTime;$/;"	m	class:MediaStreamContext	file:
fragmentURI	fragmentcollector_hls.h	/^	char *fragmentURI; \/**< pointer (into playlist) to URI of current fragment-of-interest *\/$/;"	m	class:TrackState
fragmentURIFromIndex	fragmentcollector_hls.h	/^	char fragmentURIFromIndex[MAX_URI_LENGTH]; \/**< storage for uri generated by GetFragmentUriFromIndex *\/$/;"	m	class:TrackState
fragmentduration	fragmentcollector_mpd.cpp	/^	double fragmentduration;$/;"	m	struct:HeaderFetchParams	file:
frameMBSOnlyFlag	tsprocessor.h	/^         int frameMBSOnlyFlag;$/;"	m	struct:TSProcessor::_H264SPS
frameRate	fragmentcollector_hls.h	/^	double frameRate;		\/**< Frame Rate *\/$/;"	m	struct:HlsStreamInfo
gAampCfg	aamplogging.cpp	/^static char gAampCfg[] = "c:\/tmp\/aamp.cfg";$/;"	v	file:
gAampCliCfg	aamplogging.cpp	/^static char gAampCliCfg[] = "c:\/tmp\/aampcli.cfg";$/;"	v	file:
gAampDemuxHLSAudioTsTrack	priv_aamp.h	/^	int gAampDemuxHLSAudioTsTrack;          \/**< Demux Audio track from HLS transport stream*\/$/;"	m	class:GlobalConfigAAMP
gAampDemuxHLSVideoTsTrack	priv_aamp.h	/^	int gAampDemuxHLSVideoTsTrack;          \/**< Demux Video track from HLS transport stream*\/$/;"	m	class:GlobalConfigAAMP
gAampLog	aamplogging.cpp	/^static char gAampLog[] = "c:\/tmp\/aamp.log";$/;"	v	file:
gAampMergeAudioTrack	priv_aamp.h	/^	int gAampMergeAudioTrack;               \/**< Merge audio track and queued till video processed*\/$/;"	m	class:GlobalConfigAAMP
gActivePrivAAMPs	main_aamp.cpp	/^} gActivePrivAAMPs[AAMP_MAX_SIMULTANEOUS_INSTANCES] = { { NULL, false, 0 }, { NULL, false, 0 } };$/;"	v	typeref:struct:__anon4	file:
gCond	main_aamp.cpp	/^static pthread_cond_t gCond = PTHREAD_COND_INITIALIZER;$/;"	v	file:
gDeferredDrmLicRequestPending	fragmentcollector_hls.cpp	/^static bool gDeferredDrmLicRequestPending = false;         \/**< Indicates if deferred DRM request is pending*\/$/;"	v	file:
gDeferredDrmLicTagUnderProcessing	fragmentcollector_hls.cpp	/^static bool gDeferredDrmLicTagUnderProcessing = false;     \/**< Indicates if deferred DRM request tag is under processing*\/$/;"	v	file:
gDeferredDrmMetaDataSha1Hash	fragmentcollector_hls.cpp	/^static unsigned char gDeferredDrmMetaDataSha1Hash[DRM_SHA1_HASH_LEN]; \/**< Sha1 hash of meta-data for deferred DRM license acquisition*\/$/;"	v	file:
gDeferredDrmTime	fragmentcollector_hls.cpp	/^static long long gDeferredDrmTime = 0;                     \/**< Time at which deferred DRM license to be requested*\/$/;"	v	file:
gDrmMutex	fragmentcollector_hls.cpp	/^pthread_mutex_t gDrmMutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
gMutex	main_aamp.cpp	/^static pthread_mutex_t gMutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
gPreservePipeline	priv_aamp.h	/^	int gPreservePipeline;                  \/**< Flush instead of teardown*\/$/;"	m	class:GlobalConfigAAMP
gThrottle	priv_aamp.h	/^	int gThrottle;                          \/**< Regulate output data flow*\/$/;"	m	class:GlobalConfigAAMP
generatePATandPMT	tsprocessor.cpp	/^bool TSProcessor::generatePATandPMT(bool trick, unsigned char **buff, int *buflen, bool bHandleMCTrick)$/;"	f	class:TSProcessor
getAampCfgPath	aamplogging.cpp	/^const char* AampLogManager::getAampCfgPath(void)$/;"	f	class:AampLogManager
getAampCliCfgPath	aamplogging.cpp	/^const char* AampLogManager::getAampCliCfgPath(void)$/;"	f	class:AampLogManager
getAudioComponents	tsprocessor.cpp	/^void TSProcessor::getAudioComponents(const RecordingComponent** audioComponentsPtr, int &count)$/;"	f	class:TSProcessor
getBasePTS	tsprocessor.cpp	/^	unsigned long long getBasePTS()$/;"	f	class:Demuxer
getBits	tsprocessor.cpp	/^unsigned int TSProcessor::getBits(unsigned char *& p, int& mask, int bitCount)$/;"	f	class:TSProcessor
getCCDecoderHandle	aampgstplayer.cpp	/^unsigned long AAMPGstPlayer::getCCDecoderHandle()$/;"	f	class:AAMPGstPlayer
getCCDecoderHandle	main_aamp.h	/^	virtual unsigned long getCCDecoderHandle(void) { return 0; };$/;"	f	class:StreamSink
getCurrentTime	tsprocessor.cpp	/^long long TSProcessor::getCurrentTime()$/;"	f	class:TSProcessor
getEstbMac	streamabstraction.cpp	/^static bool getEstbMac(char* mac)$/;"	f	file:
getSExpGolomb	tsprocessor.cpp	/^int TSProcessor::getSExpGolomb(unsigned char *& p, int& bit)$/;"	f	class:TSProcessor
getStreamType	main_aamp.cpp	/^int PrivateInstanceAAMP::getStreamType()$/;"	f	class:PrivateInstanceAAMP
getStreamTypeString	main_aamp.cpp	/^std::string PrivateInstanceAAMP::getStreamTypeString()$/;"	f	class:PrivateInstanceAAMP
getTuneEventsJSON	priv_aamp.h	/^	void getTuneEventsJSON(std::stringstream &outSS, const std::string &streamType, const char *url, bool success)$/;"	f	class:ProfileEventAAMP
getUExpGolomb	tsprocessor.cpp	/^unsigned int TSProcessor::getUExpGolomb(unsigned char *& p, int& mask)$/;"	f	class:TSProcessor
get_crc32	tsprocessor.cpp	/^static uint32_t get_crc32(unsigned char *data, int size, uint32_t initial = 0xffffffff)$/;"	f	file:
getch	main_aamp.cpp	/^int getch(void)$/;"	f
gpGlobalConfig	main_aamp.cpp	/^GlobalConfigAAMP *gpGlobalConfig;$/;"	v
group_id	fragmentcollector_hls.h	/^	const char *group_id;	\/**< Group ID *\/$/;"	m	struct:MediaInfo
gst	priv_aamp.h	/^	bool gst;        \/**< Gstreamer logs*\/$/;"	m	class:AampLogManager
gstPropsDirty	aampgstplayer.cpp	/^	bool gstPropsDirty; \/\/Flag used to check if gst props need to be set at start.$/;"	m	struct:AAMPGstPlayerPriv	file:
gstreamerBufferingBeforePlay	priv_aamp.h	/^	bool gstreamerBufferingBeforePlay;      \/**< Enable pre buffering logic which ensures minimum buffering is done before pipeline play*\/$/;"	m	class:GlobalConfigAAMP
handle	main_aamp.h	/^			unsigned long handle;	\/**< Closed caption handle *\/$/;"	m	struct:AAMPEvent::__anon9::__anon15
harvest	priv_aamp.h	/^	int harvest;                \/**< Save decrypted fragments for debugging*\/$/;"	m	class:GlobalConfigAAMP
hasDrm	StreamAbstractionAAMP.h	/^	bool hasDrm;                            \/**< denotes if the current asset is DRM protected*\/$/;"	m	class:StreamAbstractionAAMP
hasDrm	main_aamp.h	/^			bool hasDrm;                                                    \/**< Drm enabled *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
hasEndListTag	fragmentcollector_hls.h	/^	bool hasEndListTag;								\/**< Flag indicating if End list is present or not *\/$/;"	m	class:StreamAbstractionAAMP_HLS
header_callback	main_aamp.cpp	/^static size_t header_callback(void *ptr, size_t size, size_t nmemb, void *user_data)$/;"	f	file:
height	StreamAbstractionAAMP.h	/^	int height;     \/**< Height in pixels*\/$/;"	m	struct:StreamResolution
height	main_aamp.h	/^			int height;                                                     \/**< Maximum video height *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
height	main_aamp.h	/^			int height;                 \/**< Video height *\/$/;"	m	struct:AAMPEvent::__anon9::__anon13
hlsAVTrackSyncUsingStartTime	priv_aamp.h	/^	bool hlsAVTrackSyncUsingStartTime;      \/**< HLS A\/V track to be synced with start time*\/$/;"	m	class:GlobalConfigAAMP
httpProxy	priv_aamp.h	/^	const char* httpProxy;                  \/**< HTTP proxy address*\/$/;"	m	class:GlobalConfigAAMP
httpRespHeaderData	priv_aamp.h	/^struct httpRespHeaderData {$/;"	s
httpRespHeaders	priv_aamp.h	/^	httpRespHeaderData httpRespHeaders[MAX_CURL_INSTANCE_COUNT];$/;"	m	class:PrivateInstanceAAMP
id	priv_aamp.h	/^		ProfilerBucketType id;      \/**< Event identifier *\/$/;"	m	class:ProfileEventAAMP::TuneEvent
iframeBitrate	priv_aamp.h	/^	long iframeBitrate;                     \/**< Default bitrate for iframe track selection for non-4K assets*\/$/;"	m	class:GlobalConfigAAMP
iframeBitrate4K	priv_aamp.h	/^	long iframeBitrate4K;                   \/**< Default bitrate for iframe track selection for 4K assets*\/$/;"	m	class:GlobalConfigAAMP
index	fragmentcollector_hls.h	/^	GrowableBuffer index; 			\/**< packed IndexNode records for associated playlist *\/$/;"	m	class:TrackState
indexCount	fragmentcollector_hls.h	/^	int indexCount; 				\/**< number of indexed fragments in currently indexed playlist *\/$/;"	m	class:TrackState
indexFirstMediaSequenceNumber	fragmentcollector_hls.h	/^	long long indexFirstMediaSequenceNumber; \/**< first media sequence number from indexed manifest *\/$/;"	m	class:TrackState
index_len	fragmentcollector_mpd.cpp	/^	size_t index_len;$/;"	m	class:MediaStreamContext	file:
index_ptr	fragmentcollector_mpd.cpp	/^	char *index_ptr;$/;"	m	class:MediaStreamContext	file:
info	priv_aamp.h	/^	bool info;       \/**< Info level*\/$/;"	m	class:AampLogManager
init	tsprocessor.cpp	/^	void init(double position, double duration, bool trickmode, bool resetBasePTS)$/;"	f	class:Demuxer
initData	fragmentcollector_mpd.cpp	/^	unsigned char *initData;$/;"	m	struct:DrmSessionParams	file:
initDataLen	fragmentcollector_mpd.cpp	/^	int initDataLen;$/;"	m	struct:DrmSessionParams	file:
init_crc32	tsprocessor.cpp	/^static void init_crc32()$/;"	f	file:
initialTuneTimeMs	priv_aamp.h	/^	long long initialTuneTimeMs;$/;"	m	class:PrivateInstanceAAMP
initialization	fragmentcollector_mpd.cpp	/^	std::string initialization;$/;"	m	class:MediaStreamContext	file:
initialization	fragmentcollector_mpd.cpp	/^	string initialization;$/;"	m	struct:HeaderFetchParams	file:
initialized	aampgstplayer.h	/^	static bool initialized;$/;"	m	class:AAMPGstPlayer
insertPCR	tsprocessor.cpp	/^void TSProcessor::insertPCR(unsigned char *packet, int pid)$/;"	f	class:TSProcessor
insertPatPmt	tsprocessor.cpp	/^int TSProcessor::insertPatPmt(unsigned char *buffer, bool trick, int bufferSize)$/;"	f	class:TSProcessor
instreamID	fragmentcollector_hls.h	/^	const char *instreamID;	\/**< StreamID *\/$/;"	m	struct:MediaInfo
internalReTune	priv_aamp.h	/^	bool internalReTune;                    \/**< Internal re-tune on underflows\/ pts errors*\/$/;"	m	class:GlobalConfigAAMP
isDefault	fragmentcollector_hls.h	/^	bool isDefault;			\/**< IsDefault *\/$/;"	m	struct:MediaInfo
isIframeTrack	StreamAbstractionAAMP.h	/^	bool isIframeTrack;             \/**< indicates if the stream is iframe stream*\/$/;"	m	struct:StreamInfo
isLogLevelAllowed	aamplogging.cpp	/^bool AampLogManager::isLogLevelAllowed(AAMP_LogLevel chkLevel)$/;"	f	class:AampLogManager
isLogworthyErrorCode	aamplogging.cpp	/^bool AampLogManager::isLogworthyErrorCode(int errorCode)$/;"	f	class:AampLogManager
isUsingLocalConfigForPreferredDRM	priv_aamp.h	/^	bool  isUsingLocalConfigForPreferredDRM;          \/**< Preferred DRM configured as part of aamp.cfg *\/$/;"	m	class:GlobalConfigAAMP
isWidevine	fragmentcollector_mpd.cpp	/^	bool isWidevine;$/;"	m	struct:DrmSessionParams	file:
isinitialization	fragmentcollector_mpd.cpp	/^	bool isinitialization;$/;"	m	struct:HeaderFetchParams	file:
jsEvent	main_aamp.h	/^		} jsEvent;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon17
jsObject	main_aamp.h	/^			void*  jsObject;            \/**< Pointer to the Java Scipt Object *\/$/;"	m	struct:AAMPEvent::__anon9::__anon17
keepLastFrame	aampgstplayer.cpp	/^	bool keepLastFrame; \/\/Keep last frame over next pipeline delete\/ create cycle$/;"	m	struct:AAMPGstPlayerPriv	file:
language	fragmentcollector_hls.h	/^	const char *language;	\/**< Language *\/$/;"	m	struct:MediaInfo
language	priv_aamp.h	/^	char language[MAX_LANGUAGE_TAG_LENGTH];  \/\/ current language set$/;"	m	class:PrivateInstanceAAMP
languageCount	main_aamp.h	/^			int languageCount;                                              \/**< Available language count *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
languages	main_aamp.h	/^			char languages[MAX_LANGUAGE_COUNT][MAX_LANGUAGE_TAG_LENGTH];    \/**< Available languages *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
lastKnownPTS	aampgstplayer.cpp	/^	gint64 lastKnownPTS; \/\/To store the PTS of last displayed video$/;"	m	struct:AAMPGstPlayerPriv	file:
lastPlaylistDownloadTimeMS	fragmentcollector_hls.h	/^	long long lastPlaylistDownloadTimeMS; \/**< UTC time at which playlist was downloaded *\/$/;"	m	class:TrackState
lastPlaylistUpdateMS	fragmentcollector_mpd.cpp	/^	long long lastPlaylistUpdateMS;$/;"	m	struct:FragmentDownloadParams	file:
lastProcessedKeyId	fragmentcollector_mpd.cpp	/^	unsigned char *lastProcessedKeyId;$/;"	m	class:PrivateStreamAbstractionMPD	file:
lastProcessedKeyIdLen	fragmentcollector_mpd.cpp	/^	int lastProcessedKeyIdLen;$/;"	m	class:PrivateStreamAbstractionMPD	file:
lastSegmentNumber	fragmentcollector_mpd.cpp	/^	uint64_t lastSegmentNumber;$/;"	m	class:MediaStreamContext	file:
lastSegmentTime	fragmentcollector_mpd.cpp	/^	uint64_t lastSegmentTime;$/;"	m	class:MediaStreamContext	file:
lastSelectedProfileIndex	fragmentcollector_hls.h	/^	int lastSelectedProfileIndex; 	\/**< Variable  to restore in case of playlist download failure *\/$/;"	m	class:StreamAbstractionAAMP_HLS
lastTuneType	priv_aamp.h	/^	TuneType lastTuneType;$/;"	m	class:PrivateInstanceAAMP
lastUnderFlowTimeMs	priv_aamp.h	/^	long long lastUnderFlowTimeMs[AAMP_TRACK_COUNT];$/;"	m	class:PrivateInstanceAAMP
latencyLogging	priv_aamp.h	/^	bool latencyLogging[MAX_SUPPORTED_LATENCY_LOGGING_TYPES]; \/**< Latency logging for Video, Audio, Manifest download - Refer MediaType on main_aamp.h *\/ $/;"	m	class:AampLogManager
len	priv_aamp.h	/^	size_t len;     \/**< Buffer size *\/$/;"	m	struct:GrowableBuffer
length	priv_aamp.h	/^	    unsigned int length;$/;"	m	struct:PrivateInstanceAAMP::_AAMP2ReceiverMsg
licenceFromManifest	priv_aamp.h	/^	bool licenceFromManifest;$/;"	m	class:PrivateInstanceAAMP
licenseAnonymousRequest	priv_aamp.h	/^	bool licenseAnonymousRequest;           \/**< Acquire license without token*\/$/;"	m	class:GlobalConfigAAMP
licenseRetryWaitTime	priv_aamp.h	/^	int licenseRetryWaitTime;$/;"	m	class:GlobalConfigAAMP
licenseServerLocalOverride	priv_aamp.h	/^	bool licenseServerLocalOverride;        \/**< Enable license server local overriding*\/$/;"	m	class:GlobalConfigAAMP
licenseServerURL	priv_aamp.h	/^	char* licenseServerURL;                 \/**< License server URL*\/$/;"	m	class:GlobalConfigAAMP
linearTrickplayFPS	priv_aamp.h	/^	int linearTrickplayFPS;                 \/**< Trickplay frames per second for LIVE*\/$/;"	m	class:GlobalConfigAAMP
linearTrickplayFPSLocalOverride	priv_aamp.h	/^	bool linearTrickplayFPSLocalOverride;   \/**< Enabled LIVE Trickplay FPS local overriding*\/$/;"	m	class:GlobalConfigAAMP
liveOffset	priv_aamp.h	/^	int liveOffset;                         \/**< Current LIVE offset*\/$/;"	m	class:GlobalConfigAAMP
log2MaxFrameNumMinus4	tsprocessor.h	/^         int log2MaxFrameNumMinus4;$/;"	m	struct:TSProcessor::_H264SPS
log2MaxPicOrderCntLsbMinus4	tsprocessor.h	/^         int log2MaxPicOrderCntLsbMinus4;$/;"	m	struct:TSProcessor::_H264SPS
logging	priv_aamp.h	/^	AampLogManager logging;             	\/**< Aamp log manager class*\/$/;"	m	class:GlobalConfigAAMP
logprintf	aamplogging.cpp	/^void logprintf(const char *format, ...)$/;"	f
mABREnabled	priv_aamp.h	/^	bool mABREnabled;                   \/**< Flag that denotes if ABR is enabled *\/$/;"	m	class:PrivateInstanceAAMP
mAbrBitrateData	priv_aamp.h	/^	std::vector< std::pair<long long,long> > mAbrBitrateData;$/;"	m	class:PrivateInstanceAAMP
mAbrManager	StreamAbstractionAAMP.h	/^	ABRManager mAbrManager;             \/**< Pointer to abr manager*\/$/;"	m	class:StreamAbstractionAAMP
mAdPosition	priv_aamp.h	/^	double mAdPosition;$/;"	m	class:PrivateInstanceAAMP
mAdUrl	priv_aamp.h	/^	char mAdUrl[MAX_URI_LENGTH];$/;"	m	class:PrivateInstanceAAMP
mAudioFormat	priv_aamp.h	/^	StreamOutputFormat mAudioFormat;$/;"	m	class:PrivateInstanceAAMP
mAudioType	fragmentcollector_mpd.cpp	/^	AudioType mAudioType;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mAvailableBandwidth	priv_aamp.h	/^	long mAvailableBandwidth;$/;"	m	class:PrivateInstanceAAMP
mBitrateIndexMap	fragmentcollector_mpd.cpp	/^	std::unordered_map<long, int> mBitrateIndexMap;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mCMSha1Hash	fragmentcollector_hls.h	/^	char* mCMSha1Hash;	\/**< variable to store ShaID*\/$/;"	m	class:TrackState
mChannelOverrideMap	main_aamp.cpp	/^static std::list<ChannelInfo> mChannelOverrideMap;$/;"	v	file:
mCheckForRampdown	StreamAbstractionAAMP.h	/^	bool mCheckForRampdown;			\/**< flag to indicate if rampdown is attempted or not *\/$/;"	m	class:StreamAbstractionAAMP
mCond	StreamAbstractionAAMP.h	/^	pthread_cond_t mCond;               \/**< condition for A\/V track catchup logic*\/$/;"	m	class:StreamAbstractionAAMP
mCondDiscontinuity	priv_aamp.h	/^	pthread_cond_t mCondDiscontinuity;$/;"	m	class:PrivateInstanceAAMP
mContentType	priv_aamp.h	/^	ContentType mContentType;$/;"	m	class:PrivateInstanceAAMP
mContext	fragmentcollector_mpd.cpp	/^	StreamAbstractionAAMP_MPD* mContext;$/;"	m	class:MediaStreamContext	file:
mContext	fragmentcollector_mpd.cpp	/^	StreamAbstractionAAMP_MPD* mContext;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mCulledSeconds	fragmentcollector_hls.h	/^	double mCulledSeconds;                  \/**< Total culled duration *\/$/;"	m	class:TrackState
mCurrentBandwidth	StreamAbstractionAAMP.h	/^	long mCurrentBandwidth;             \/**< stores current bandwidth*\/$/;"	m	class:StreamAbstractionAAMP
mCurrentDrm	priv_aamp.h	/^	DRMSystems mCurrentDrm;$/;"	m	class:PrivateInstanceAAMP
mCurrentPeriodIdx	fragmentcollector_mpd.cpp	/^	int mCurrentPeriodIdx;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mCustomHeaders	priv_aamp.h	/^	std::unordered_map<std::string, std::vector<std::string>> mCustomHeaders;$/;"	m	class:PrivateInstanceAAMP
mDiscontinuityIndex	fragmentcollector_hls.h	/^	GrowableBuffer mDiscontinuityIndex;  \/**< discontinuity start position mapping of associated playlist *\/$/;"	m	class:TrackState
mDiscontinuityIndexCount	fragmentcollector_hls.h	/^	int mDiscontinuityIndexCount; \/**< number of records in discontinuity position index *\/$/;"	m	class:TrackState
mDiscontinuityTuneOperationId	priv_aamp.h	/^	gint mDiscontinuityTuneOperationId;$/;"	m	class:PrivateInstanceAAMP
mDiscontinuityTuneOperationInProgress	priv_aamp.h	/^	bool mDiscontinuityTuneOperationInProgress;$/;"	m	class:PrivateInstanceAAMP
mDownloadsDisabled	priv_aamp.h	/^	pthread_cond_t mDownloadsDisabled;$/;"	m	class:PrivateInstanceAAMP
mDownloadsEnabled	priv_aamp.h	/^	bool mDownloadsEnabled;$/;"	m	class:PrivateInstanceAAMP
mDrm	fragmentcollector_hls.h	/^	std::shared_ptr<HlsDrmBase> mDrm;       \/**< DRM decrypt context*\/$/;"	m	class:TrackState
mDrmInfo	fragmentcollector_hls.h	/^	struct DrmInfo mDrmInfo;	\/**< Structure variable to hold Drm Information *\/$/;"	m	class:TrackState	typeref:struct:TrackState::DrmInfo
mDrmKeyTagCount	fragmentcollector_hls.h	/^	int mDrmKeyTagCount;  \/**< number of EXT-X-KEY tags present in playlist *\/$/;"	m	class:TrackState
mDrmLicenseRequestPending	fragmentcollector_hls.h	/^	bool mDrmLicenseRequestPending;         \/**< Indicates if DRM License Request is Pending*\/$/;"	m	class:TrackState
mDrmMetaDataIndex	fragmentcollector_hls.h	/^	GrowableBuffer mDrmMetaDataIndex;  \/**< DrmMetadata records for associated playlist *\/$/;"	m	class:TrackState
mDrmMetaDataIndexCount	fragmentcollector_hls.h	/^	int mDrmMetaDataIndexCount; \/**< number of DrmMetadata records in currently indexed playlist *\/$/;"	m	class:TrackState
mDrmMetaDataIndexPosition	fragmentcollector_hls.h	/^	int mDrmMetaDataIndexPosition;	\/**< Variable to store Drm Meta data Index position*\/$/;"	m	class:TrackState
mDrmTimeStamp	fragmentcollector_hls.h	/^	long long mDrmTimeStamp;	\/**< variable to store Drm Time Stamp *\/$/;"	m	class:TrackState
mDuration	fragmentcollector_hls.h	/^	double mDuration;  \/** Duration of the track*\/$/;"	m	class:TrackState
mESChangeStatus	StreamAbstractionAAMP.h	/^	bool mESChangeStatus;               \/**< flag value which is used to call pipeline configuration if the audio type changed in mid stream *\/$/;"	m	class:StreamAbstractionAAMP
mEnableCache	priv_aamp.h	/^	bool mEnableCache;$/;"	m	class:PrivateInstanceAAMP
mEndPosition	fragmentcollector_mpd.cpp	/^	double mEndPosition;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mEventListener	priv_aamp.h	/^	AAMPEventListener* mEventListener;$/;"	m	class:PrivateInstanceAAMP
mEventListeners	priv_aamp.h	/^	ListenerData* mEventListeners[AAMP_MAX_NUM_EVENTS];$/;"	m	class:PrivateInstanceAAMP
mFirstPTS	fragmentcollector_mpd.cpp	/^	double mFirstPTS;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mFirstTune	priv_aamp.h	/^	bool mFirstTune;			\/\/To identify the first tune after load.$/;"	m	class:PrivateInstanceAAMP
mForceProcessDrmMetadata	fragmentcollector_hls.h	/^	bool mForceProcessDrmMetadata;          \/**< Indicates if processing drm metadata to be forced on indexing*\/$/;"	m	class:TrackState
mFormat	priv_aamp.h	/^	StreamOutputFormat mFormat;$/;"	m	class:PrivateInstanceAAMP
mIndexingInProgress	fragmentcollector_hls.h	/^	bool mIndexingInProgress;  \/**< indicates if indexing is in progress*\/$/;"	m	class:TrackState
mInitFragmentInfo	fragmentcollector_hls.h	/^	const char* mInitFragmentInfo;          \/**< Holds init fragment Information index*\/$/;"	m	class:TrackState
mInitSuccess	priv_aamp.h	/^	bool mInitSuccess;	\/\/TODO: Need to replace with player state$/;"	m	class:PrivateInstanceAAMP
mInjectInitFragment	fragmentcollector_hls.h	/^	bool mInjectInitFragment;               \/**< Indicates if init fragment injection is required*\/$/;"	m	class:TrackState
mInternalStreamSink	main_aamp.h	/^	StreamSink* mInternalStreamSink;    \/**< Pointer to stream sink *\/$/;"	m	class:PlayerInstanceAAMP
mIsAtLivePoint	StreamAbstractionAAMP.h	/^	bool mIsAtLivePoint;                    \/**< flag that denotes if playback is at live point*\/$/;"	m	class:StreamAbstractionAAMP
mIsDash	priv_aamp.h	/^	bool mIsDash;$/;"	m	class:PrivateInstanceAAMP
mIsFirstBuffer	StreamAbstractionAAMP.h	/^	bool mIsFirstBuffer;                    \/** <flag that denotes if the first buffer was processed or not*\/$/;"	m	class:StreamAbstractionAAMP
mIsFirstRequestToFOG	priv_aamp.h	/^	bool mIsFirstRequestToFOG;$/;"	m	class:PrivateInstanceAAMP
mIsFogTSB	fragmentcollector_mpd.cpp	/^	bool mIsFogTSB;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mIsIframeTrackPresent	fragmentcollector_mpd.cpp	/^	bool mIsIframeTrackPresent;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mIsLive	fragmentcollector_mpd.cpp	/^	bool mIsLive;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mIsLive	priv_aamp.h	/^	bool mIsLive;$/;"	m	class:PrivateInstanceAAMP
mIsLocalPlayback	priv_aamp.h	/^	bool mIsLocalPlayback; \/** indicates if the playback is from FOG(TSB\/IP-DVR) *\/$/;"	m	class:PrivateInstanceAAMP
mIsPaused	StreamAbstractionAAMP.h	/^	bool mIsPaused;                     \/**< paused state or not *\/$/;"	m	class:StreamAbstractionAAMP
mIsPlaybackStalled	StreamAbstractionAAMP.h	/^	bool mIsPlaybackStalled;                \/**< flag that denotes if playback was stalled or not*\/$/;"	m	class:StreamAbstractionAAMP
mIsRetuneInProgress	priv_aamp.h	/^	bool mIsRetuneInProgress;$/;"	m	class:PrivateInstanceAAMP
mIsVSS	priv_aamp.h	/^	bool mIsVSS;       \/**< Indicates if stream is VSS, updated during Tune*\/$/;"	m	class:PrivateInstanceAAMP
mIscDVR	priv_aamp.h	/^	bool mIscDVR;$/;"	m	class:PrivateInstanceAAMP
mJSBinding_DL	main_aamp.h	/^	void* mJSBinding_DL;                \/**< Handle to AAMP plugin dynamic lib.  *\/$/;"	m	class:PlayerInstanceAAMP
mLangList	fragmentcollector_mpd.cpp	/^	std::set<std::string> mLangList;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mLanguageList	priv_aamp.h	/^	char mLanguageList[MAX_LANGUAGE_COUNT][MAX_LANGUAGE_TAG_LENGTH]; \/\/ list of languages in stream$/;"	m	class:PrivateInstanceAAMP
mLastMatchedDiscontPosition	fragmentcollector_hls.h	/^	double mLastMatchedDiscontPosition;     \/**< Holds discontinuity position last matched  by other track *\/$/;"	m	class:TrackState
mLastPausedTimeStamp	StreamAbstractionAAMP.h	/^	long long mLastPausedTimeStamp;     \/**< stores timestamp of last pause operation *\/$/;"	m	class:StreamAbstractionAAMP
mLastPlaylistDownloadTimeMs	fragmentcollector_mpd.cpp	/^	uint64_t mLastPlaylistDownloadTimeMs;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mLastVideoFragCheckedforABR	StreamAbstractionAAMP.h	/^	int mLastVideoFragCheckedforABR;    \/**< Last video fragment for which ABR is checked*\/$/;"	m	class:StreamAbstractionAAMP
mLastVideoFragParsedTimeMS	StreamAbstractionAAMP.h	/^	double mLastVideoFragParsedTimeMS;  \/**< timestamp when last video fragment was parsed *\/$/;"	m	class:StreamAbstractionAAMP
mLicenseProxy	priv_aamp.h	/^	char *mLicenseProxy;                \/**< proxy for license acquisition *\/$/;"	m	class:PrivateInstanceAAMP
mLiveOffset	priv_aamp.h	/^	int mLiveOffset;$/;"	m	class:PrivateInstanceAAMP
mLock	StreamAbstractionAAMP.h	/^	pthread_mutex_t mLock;              \/**< lock for A\/V track catchup logic*\/$/;"	m	class:StreamAbstractionAAMP
mLock	priv_aamp.h	/^	pthread_mutex_t mLock;\/\/ = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:PrivateInstanceAAMP
mMPDPeriodsInfo	fragmentcollector_mpd.cpp	/^	vector<PeriodInfo> mMPDPeriodsInfo;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mMaxLanguageCount	priv_aamp.h	/^	int  mMaxLanguageCount;$/;"	m	class:PrivateInstanceAAMP
mMediaStreamContext	fragmentcollector_mpd.cpp	/^	MediaStreamContext *mMediaStreamContext[AAMP_TRACK_COUNT];$/;"	m	class:PrivateStreamAbstractionMPD	file:
mMediaTypeName	fragmentcollector_mpd.cpp	/^static const char *mMediaTypeName[] = { "video", "audio" };$/;"	v	file:
mMinUpdateDurationMs	fragmentcollector_mpd.cpp	/^	int64_t mMinUpdateDurationMs;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mMutexAttr	priv_aamp.h	/^	pthread_mutexattr_t mMutexAttr;$/;"	m	class:PrivateInstanceAAMP
mNetworkDownDetected	StreamAbstractionAAMP.h	/^	bool mNetworkDownDetected;              \/**< Network down status indicator *\/$/;"	m	class:StreamAbstractionAAMP
mNetworkProxy	priv_aamp.h	/^	char *mNetworkProxy;                \/**< proxy for download requests *\/$/;"	m	class:PrivateInstanceAAMP
mNewLiveOffsetflag	priv_aamp.h	/^	bool mNewLiveOffsetflag;$/;"	m	class:PrivateInstanceAAMP
mNumberOfTracks	fragmentcollector_hls.h	/^	int mNumberOfTracks;							\/**< Number of media tracks.*\/$/;"	m	class:StreamAbstractionAAMP_HLS
mNumberOfTracks	fragmentcollector_mpd.cpp	/^	int mNumberOfTracks;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mNwConsistencyBypass	StreamAbstractionAAMP.h	/^	long mNwConsistencyBypass;          \/**< Network consistency bypass**\/$/;"	m	class:StreamAbstractionAAMP
mPendingAsyncEvents	priv_aamp.h	/^	std::map<gint, bool> mPendingAsyncEvents;$/;"	m	class:PrivateInstanceAAMP
mPeriodEndTime	fragmentcollector_mpd.cpp	/^	uint64_t mPeriodEndTime;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPeriodId	fragmentcollector_mpd.cpp	/^	std::string mPeriodId;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPeriodStartTime	fragmentcollector_mpd.cpp	/^	uint64_t mPeriodStartTime;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPersistedProfileIndex	priv_aamp.h	/^	int  mPersistedProfileIndex;$/;"	m	class:PrivateInstanceAAMP
mPlayerLoadTime	priv_aamp.h	/^	long long mPlayerLoadTime;$/;"	m	class:PrivateInstanceAAMP
mPlayingAd	priv_aamp.h	/^	bool mPlayingAd;$/;"	m	class:PrivateInstanceAAMP
mPlaylistCache	priv_aamp.h	/^	std::unordered_map<std::string, std::pair<GrowableBuffer*, char*>> mPlaylistCache;$/;"	m	class:PrivateInstanceAAMP
mPlaylistIndexed	fragmentcollector_hls.h	/^	pthread_cond_t mPlaylistIndexed;        \/**< Notifies after a playlist indexing operation *\/$/;"	m	class:TrackState
mPlaylistMutex	fragmentcollector_hls.h	/^	pthread_mutex_t mPlaylistMutex;         \/**< protect playlist update *\/$/;"	m	class:TrackState
mPrevAdaptationSetCount	fragmentcollector_mpd.cpp	/^	int mPrevAdaptationSetCount;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPrevLastSegurlMedia	fragmentcollector_mpd.cpp	/^	std::string mPrevLastSegurlMedia;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPrevLastSegurlOffset	fragmentcollector_mpd.cpp	/^	long mPrevLastSegurlOffset; \/\/duration offset from beginning of TSB$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPrevStartTimeSeconds	fragmentcollector_mpd.cpp	/^	double mPrevStartTimeSeconds;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mPriv	fragmentcollector_mpd.h	/^	class PrivateStreamAbstractionMPD* mPriv;$/;"	m	class:StreamAbstractionAAMP_MPD	typeref:class:StreamAbstractionAAMP_MPD::PrivateStreamAbstractionMPD
mProcessingAdInsertion	priv_aamp.h	/^	bool mProcessingAdInsertion;$/;"	m	class:PrivateInstanceAAMP
mProcessingDiscontinuity	priv_aamp.h	/^	bool mProcessingDiscontinuity;$/;"	m	class:PrivateInstanceAAMP
mPushEncInitFragment	fragmentcollector_mpd.cpp	/^	bool mPushEncInitFragment;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mReportProgressPosn	priv_aamp.h	/^	double mReportProgressPosn;$/;"	m	class:PrivateInstanceAAMP
mReportProgressTime	priv_aamp.h	/^	long long mReportProgressTime;$/;"	m	class:PrivateInstanceAAMP
mSeekOperationInProgress	priv_aamp.h	/^	bool mSeekOperationInProgress;$/;"	m	class:PrivateInstanceAAMP
mSegInjectFailCount	StreamAbstractionAAMP.h	/^	int mSegInjectFailCount;            \/**< Segment Inject\/Decode fail count *\/$/;"	m	class:MediaTrack
mStartTimeStamp	StreamAbstractionAAMP.h	/^	long long mStartTimeStamp;          \/**< stores timestamp at which injection starts *\/$/;"	m	class:StreamAbstractionAAMP
mStartTimestampZero	fragmentcollector_hls.h	/^	bool mStartTimestampZero;						\/**< Flag indicating if timestamp to start is zero or not (No audio stream) *\/$/;"	m	class:StreamAbstractionAAMP_HLS
mState	priv_aamp.h	/^	PrivAAMPState mState;$/;"	m	class:PrivateInstanceAAMP
mStreamInfo	fragmentcollector_mpd.cpp	/^	StreamInfo* mStreamInfo;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mStreamSink	priv_aamp.h	/^	StreamSink* mStreamSink;$/;"	m	class:PrivateInstanceAAMP
mSyncAfterDiscontinuityInProgress	fragmentcollector_hls.h	/^	bool mSyncAfterDiscontinuityInProgress; \/**< Indicates if a synchronization after discontinuity tag is in progress*\/$/;"	m	class:TrackState
mTSBEnabled	priv_aamp.h	/^	bool mTSBEnabled;$/;"	m	class:PrivateInstanceAAMP
mTotalPausedDurationMS	StreamAbstractionAAMP.h	/^	long long mTotalPausedDurationMS;   \/**< Total duration for which stream is paused *\/$/;"	m	class:StreamAbstractionAAMP
mTrickPlayFPS	fragmentcollector_hls.h	/^	int mTrickPlayFPS;								\/**< Trick play frames per stream *\/$/;"	m	class:StreamAbstractionAAMP_HLS
mTsbBandwidth	StreamAbstractionAAMP.h	/^	long mTsbBandwidth;                 \/**< stores bandwidth when TSB is involved*\/$/;"	m	class:StreamAbstractionAAMP
mTuneAttempts	priv_aamp.h	/^	int  mTuneAttempts;			\/\/To distinguish between new tune & retries with redundant over urls.$/;"	m	class:PrivateInstanceAAMP
mTuneCompleted	priv_aamp.h	/^	bool mTuneCompleted;$/;"	m	class:PrivateInstanceAAMP
mTuneType	StreamAbstractionAAMP.h	/^	TuneType mTuneType;                     \/**< Tune type of current playback, initialize by derived classes on Init()*\/$/;"	m	class:StreamAbstractionAAMP
mTunedEventPending	priv_aamp.h	/^	bool mTunedEventPending;$/;"	m	class:PrivateInstanceAAMP
mUserRequestedBandwidth	priv_aamp.h	/^	long mUserRequestedBandwidth;       \/**< preferred bitrate set by user *\/$/;"	m	class:PrivateInstanceAAMP
m_PPS	tsprocessor.h	/^      H264PPS m_PPS[256];$/;"	m	class:TSProcessor
m_PatPmt	tsprocessor.h	/^      unsigned char *m_PatPmt;$/;"	m	class:TSProcessor
m_PatPmtLen	tsprocessor.h	/^      int m_PatPmtLen;$/;"	m	class:TSProcessor
m_PatPmtPcr	tsprocessor.h	/^      unsigned char *m_PatPmtPcr;$/;"	m	class:TSProcessor
m_PatPmtPcrLen	tsprocessor.h	/^      int m_PatPmtPcrLen;$/;"	m	class:TSProcessor
m_PatPmtTrick	tsprocessor.h	/^      unsigned char *m_PatPmtTrick;$/;"	m	class:TSProcessor
m_PatPmtTrickLen	tsprocessor.h	/^      int m_PatPmtTrickLen;$/;"	m	class:TSProcessor
m_SPS	tsprocessor.h	/^      H264SPS m_SPS[32];$/;"	m	class:TSProcessor
m_absPlayRate	tsprocessor.h	/^      double m_absPlayRate;$/;"	m	class:TSProcessor
m_actualStartPTS	tsprocessor.h	/^      long long m_actualStartPTS;$/;"	m	class:TSProcessor
m_apparentFrameRate	tsprocessor.h	/^      double m_apparentFrameRate;$/;"	m	class:TSProcessor
m_audDemuxer	tsprocessor.h	/^      Demuxer* m_audDemuxer;$/;"	m	class:TSProcessor
m_basePCR	tsprocessor.h	/^      long long m_basePCR;$/;"	m	class:TSProcessor
m_basePTSCond	tsprocessor.h	/^      pthread_cond_t m_basePTSCond;$/;"	m	class:TSProcessor
m_basePTSFromPeer	tsprocessor.h	/^      long long m_basePTSFromPeer;$/;"	m	class:TSProcessor
m_baseThrottleContentTime	tsprocessor.h	/^      long long m_baseThrottleContentTime;$/;"	m	class:TSProcessor
m_baseThrottleRealTime	tsprocessor.h	/^      long long m_baseThrottleRealTime;$/;"	m	class:TSProcessor
m_baseTime	tsprocessor.h	/^      long long m_baseTime;$/;"	m	class:TSProcessor
m_checkContinuity	tsprocessor.h	/^      bool m_checkContinuity;$/;"	m	class:TSProcessor
m_continuityCounters	tsprocessor.h	/^      unsigned char m_continuityCounters[8192];$/;"	m	class:TSProcessor
m_currFrameLength	tsprocessor.h	/^      int m_currFrameLength;$/;"	m	class:TSProcessor
m_currFrameNumber	tsprocessor.h	/^      int m_currFrameNumber;$/;"	m	class:TSProcessor
m_currFrameOffset	tsprocessor.h	/^      long long m_currFrameOffset;$/;"	m	class:TSProcessor
m_currPTS	tsprocessor.h	/^      long long m_currPTS;$/;"	m	class:TSProcessor
m_currRateAdjustedPCR	tsprocessor.h	/^      long long m_currRateAdjustedPCR;$/;"	m	class:TSProcessor
m_currRateAdjustedPTS	tsprocessor.h	/^      long long m_currRateAdjustedPTS;$/;"	m	class:TSProcessor
m_currSPSId	tsprocessor.h	/^      int m_currSPSId;      $/;"	m	class:TSProcessor
m_currStreamOffset	tsprocessor.h	/^      long long m_currStreamOffset;$/;"	m	class:TSProcessor
m_currTimeStamp	tsprocessor.h	/^      long long m_currTimeStamp;$/;"	m	class:TSProcessor
m_currentPTS	tsprocessor.h	/^      long long m_currentPTS; \/\/!< Store the current PTS value of a recording$/;"	m	class:TSProcessor
m_demux	tsprocessor.h	/^      bool m_demux;$/;"	m	class:TSProcessor
m_demuxInitialized	tsprocessor.h	/^      bool m_demuxInitialized;$/;"	m	class:TSProcessor
m_emulationPrevention	tsprocessor.h	/^      unsigned char * m_emulationPrevention;$/;"	m	class:TSProcessor
m_emulationPreventionCapacity	tsprocessor.h	/^      int m_emulationPreventionCapacity;$/;"	m	class:TSProcessor
m_emulationPreventionOffset	tsprocessor.h	/^      int m_emulationPreventionOffset;$/;"	m	class:TSProcessor
m_enabled	tsprocessor.h	/^      bool m_enabled;$/;"	m	class:TSProcessor
m_fd	priv_aamp.h	/^	int m_fd;$/;"	m	class:PrivateInstanceAAMP
m_frameHeight	tsprocessor.h	/^      int m_frameHeight;$/;"	m	class:TSProcessor
m_frameWidth	tsprocessor.h	/^      int m_frameWidth;$/;"	m	class:TSProcessor
m_framesProcessedInSegment	tsprocessor.h	/^      int m_framesProcessedInSegment;$/;"	m	class:TSProcessor
m_haveAspect	tsprocessor.h	/^      bool m_haveAspect; \/\/!< Set to 1 when it found aspect ratio of current video$/;"	m	class:TSProcessor
m_haveBaseTime	tsprocessor.h	/^      bool m_haveBaseTime;$/;"	m	class:TSProcessor
m_haveEmittedIFrame	tsprocessor.h	/^      bool m_haveEmittedIFrame;$/;"	m	class:TSProcessor
m_haveFirstPTS	tsprocessor.h	/^      bool m_haveFirstPTS; \/\/!< The value is set to 1 if first PTS found from a recording after examining few KB of initial data$/;"	m	class:TSProcessor
m_havePAT	tsprocessor.h	/^      bool m_havePAT; \/\/!< Set to 1 when PAT buffer examined and loaded all program specific information$/;"	m	class:TSProcessor
m_havePMT	tsprocessor.h	/^      bool m_havePMT; \/\/!< When PMT buffer examined the value is set to 1$/;"	m	class:TSProcessor
m_haveThrottleBase	tsprocessor.h	/^      bool m_haveThrottleBase;$/;"	m	class:TSProcessor
m_haveUpdatedFirstPTS	tsprocessor.h	/^      bool m_haveUpdatedFirstPTS;$/;"	m	class:TSProcessor
m_indexAudio	tsprocessor.h	/^      bool m_indexAudio; \/\/!< If PCR Pid matches with any Audio PIDs associated for a recording, the value will be set to 1$/;"	m	class:TSProcessor
m_insertPCR	tsprocessor.h	/^      bool m_insertPCR;$/;"	m	class:TSProcessor
m_isH264	tsprocessor.h	/^      bool m_isH264;$/;"	m	class:TSProcessor
m_isInterlaced	tsprocessor.h	/^      bool m_isInterlaced;$/;"	m	class:TSProcessor
m_isInterlacedKnown	tsprocessor.h	/^      bool m_isInterlacedKnown;$/;"	m	class:TSProcessor
m_isMCChannel	tsprocessor.h	/^      bool m_isMCChannel;$/;"	m	class:TSProcessor
m_lastPTSOfSegment	tsprocessor.h	/^      long long m_lastPTSOfSegment;$/;"	m	class:TSProcessor
m_lastThrottleContentTime	tsprocessor.h	/^      long long m_lastThrottleContentTime;$/;"	m	class:TSProcessor
m_lastThrottleRealTime	tsprocessor.h	/^      long long m_lastThrottleRealTime;$/;"	m	class:TSProcessor
m_last_frame_time	tsprocessor.h	/^      long long m_last_frame_time;$/;"	m	class:TSProcessor
m_mutex	tsprocessor.h	/^      pthread_mutex_t m_mutex;$/;"	m	class:TSProcessor
m_needDiscontinuity	tsprocessor.h	/^      bool m_needDiscontinuity;$/;"	m	class:TSProcessor
m_nullPFrame	tsprocessor.h	/^      unsigned char *m_nullPFrame;$/;"	m	class:TSProcessor
m_nullPFrameHeight	tsprocessor.h	/^      int m_nullPFrameHeight;$/;"	m	class:TSProcessor
m_nullPFrameLength	tsprocessor.h	/^      int m_nullPFrameLength;$/;"	m	class:TSProcessor
m_nullPFrameNextCount	tsprocessor.h	/^      int m_nullPFrameNextCount;$/;"	m	class:TSProcessor
m_nullPFrameOffset	tsprocessor.h	/^      int m_nullPFrameOffset;$/;"	m	class:TSProcessor
m_nullPFrameWidth	tsprocessor.h	/^      int m_nullPFrameWidth;$/;"	m	class:TSProcessor
m_packetSize	tsprocessor.h	/^      int m_packetSize;$/;"	m	class:TSProcessor
m_packetStartAfterFirstPTS	tsprocessor.h	/^      int m_packetStartAfterFirstPTS;$/;"	m	class:TSProcessor
m_patCounter	tsprocessor.h	/^      int m_patCounter;$/;"	m	class:TSProcessor
m_pcrPerPTSCount	tsprocessor.h	/^      int m_pcrPerPTSCount;$/;"	m	class:TSProcessor
m_pcrPid	tsprocessor.h	/^      int m_pcrPid;$/;"	m	class:TSProcessor
m_peerTSProcessor	tsprocessor.h	/^      TSProcessor* m_peerTSProcessor;$/;"	m	class:TSProcessor
m_picOrderCount	tsprocessor.h	/^      int m_picOrderCount;$/;"	m	class:TSProcessor
m_pidFilter	tsprocessor.h	/^      unsigned char m_pidFilter[8192];$/;"	m	class:TSProcessor
m_pidFilterTrick	tsprocessor.h	/^      unsigned char m_pidFilterTrick[8192];$/;"	m	class:TSProcessor
m_playMode	tsprocessor.h	/^      PlayMode m_playMode;$/;"	m	class:TSProcessor
m_playModeNext	tsprocessor.h	/^      PlayMode m_playModeNext;$/;"	m	class:TSProcessor
m_playRate	tsprocessor.h	/^      double m_playRate;$/;"	m	class:TSProcessor
m_playRateNext	tsprocessor.h	/^      double m_playRateNext;$/;"	m	class:TSProcessor
m_pmtCollector	tsprocessor.h	/^      unsigned char *m_pmtCollector; \/\/!< A buffer pointer to hold PMT data at the time of examining TS buffer$/;"	m	class:TSProcessor
m_pmtCollectorNextContinuity	tsprocessor.h	/^      int m_pmtCollectorNextContinuity; \/\/!< Keeps next continuity counter for PMT packet at the time of examine the TS Buffer$/;"	m	class:TSProcessor
m_pmtCollectorOffset	tsprocessor.h	/^      int m_pmtCollectorOffset; \/\/!< If it is set, process subsequent parts of multi-packet PMT$/;"	m	class:TSProcessor
m_pmtCollectorSectionLength	tsprocessor.h	/^      int m_pmtCollectorSectionLength; \/\/!< Update section length while examining PMT table$/;"	m	class:TSProcessor
m_pmtCounter	tsprocessor.h	/^      int m_pmtCounter;$/;"	m	class:TSProcessor
m_pmtPid	tsprocessor.h	/^      int m_pmtPid; \/\/!< For which PID the program information is available such as, audio pid, video pid, stream types, etc$/;"	m	class:TSProcessor
m_prevRateAdjustedPCR	tsprocessor.h	/^      long long m_prevRateAdjustedPCR;$/;"	m	class:TSProcessor
m_processing	tsprocessor.h	/^      bool m_processing;$/;"	m	class:TSProcessor
m_program	tsprocessor.h	/^      int m_program; \/\/!< Program number in the corresponding program map table$/;"	m	class:TSProcessor
m_queuedSegment	tsprocessor.h	/^      unsigned char * m_queuedSegment;$/;"	m	class:TSProcessor
m_queuedSegmentDiscontinuous	tsprocessor.h	/^      bool m_queuedSegmentDiscontinuous;$/;"	m	class:TSProcessor
m_queuedSegmentDuration	tsprocessor.h	/^      double m_queuedSegmentDuration;$/;"	m	class:TSProcessor
m_queuedSegmentLen	tsprocessor.h	/^      size_t m_queuedSegmentLen;$/;"	m	class:TSProcessor
m_queuedSegmentPos	tsprocessor.h	/^      double m_queuedSegmentPos;$/;"	m	class:TSProcessor
m_scanForFrameSize	tsprocessor.h	/^      bool m_scanForFrameSize;$/;"	m	class:TSProcessor
m_scanRemainder	tsprocessor.h	/^      unsigned char m_scanRemainder[MAX_SCAN_REMAINDER_SIZE*3];$/;"	m	class:TSProcessor
m_scanRemainderLimit	tsprocessor.h	/^      int m_scanRemainderLimit;$/;"	m	class:TSProcessor
m_scanRemainderSize	tsprocessor.h	/^      int m_scanRemainderSize;$/;"	m	class:TSProcessor
m_scanSkipPacketsEnabled	tsprocessor.h	/^      bool m_scanSkipPacketsEnabled;$/;"	m	class:TSProcessor
m_scrambledWarningIssued	tsprocessor.h	/^      bool m_scrambledWarningIssued;$/;"	m	class:TSProcessor
m_segmentBaseTime	tsprocessor.h	/^      long long m_segmentBaseTime;$/;"	m	class:TSProcessor
m_startPosition	tsprocessor.h	/^      double m_startPosition;$/;"	m	class:TSProcessor
m_streamOperation	tsprocessor.h	/^      StreamOperation m_streamOperation;$/;"	m	class:TSProcessor
m_throttle	tsprocessor.h	/^      bool m_throttle;$/;"	m	class:TSProcessor
m_throttleCond	tsprocessor.h	/^      pthread_cond_t m_throttleCond;$/;"	m	class:TSProcessor
m_throttleDelayForDiscontinuityMs	tsprocessor.h	/^      int m_throttleDelayForDiscontinuityMs;$/;"	m	class:TSProcessor
m_throttleDelayIgnoredMs	tsprocessor.h	/^      int m_throttleDelayIgnoredMs;$/;"	m	class:TSProcessor
m_throttleMaxDelayMs	tsprocessor.h	/^      int m_throttleMaxDelayMs;$/;"	m	class:TSProcessor
m_throttleMaxDiffSegments	tsprocessor.h	/^      int m_throttleMaxDiffSegments;$/;"	m	class:TSProcessor
m_throttlePTS	tsprocessor.h	/^      long long m_throttlePTS;$/;"	m	class:TSProcessor
m_track	tsprocessor.h	/^      int m_track;$/;"	m	class:TSProcessor
m_trickExcludeAudio	tsprocessor.h	/^      bool m_trickExcludeAudio;      $/;"	m	class:TSProcessor
m_ttsSize	tsprocessor.h	/^      int m_ttsSize;$/;"	m	class:TSProcessor
m_updatePicOrderCount	tsprocessor.h	/^      bool m_updatePicOrderCount;$/;"	m	class:TSProcessor
m_versionPAT	tsprocessor.h	/^      int m_versionPAT; \/\/!< Pat Version number$/;"	m	class:TSProcessor
m_versionPMT	tsprocessor.h	/^      int m_versionPMT; \/\/!< Version number for PMT which is being examined$/;"	m	class:TSProcessor
m_vidDemuxer	tsprocessor.h	/^      Demuxer* m_vidDemuxer;$/;"	m	class:TSProcessor
m_videoPid	tsprocessor.h	/^      int m_videoPid;$/;"	m	class:TSProcessor
macroblockAddressIncrementCodes	tsprocessor.cpp	/^static MBAddrIncCode macroblockAddressIncrementCodes[34] =$/;"	v	file:
mainManifest	fragmentcollector_hls.h	/^	GrowableBuffer mainManifest;					\/**< Main manifest buffer holder *\/$/;"	m	class:StreamAbstractionAAMP_HLS
manifestDLFailCount	fragmentcollector_hls.h	/^	int manifestDLFailCount;				\/**< Manifest Download fail count for retry*\/$/;"	m	class:TrackState
manifestUrl	fragmentcollector_mpd.cpp	/^	const char *manifestUrl;$/;"	m	struct:FragmentDescriptor	file:
manifestUrl	priv_aamp.h	/^	char manifestUrl[MAX_URI_LENGTH];$/;"	m	class:PrivateInstanceAAMP
mapMPD	priv_aamp.h	/^	int mapMPD;                 \/**< Mapping of HLS to MPD: 0=Disable, 1=Rename m3u8 to mpd, 2=COAM mapping, 3='*-nat-*.comcast.net\/' to 'ctv-nat-slivel4lb-vip.cmc.co.ndcwest.comcast.net\/'*\/$/;"	m	class:GlobalConfigAAMP
maxCachedFragmentsPerTrack	priv_aamp.h	/^	int maxCachedFragmentsPerTrack;         \/**< fragment cache length*\/$/;"	m	class:GlobalConfigAAMP
maxIntervalBtwPlaylistUpdateMs	fragmentcollector_hls.h	/^	float maxIntervalBtwPlaylistUpdateMs;			\/**< Interval between playlist update *\/$/;"	m	class:StreamAbstractionAAMP_HLS
maxPicOrderCount	tsprocessor.h	/^         int maxPicOrderCount;$/;"	m	struct:TSProcessor::_H264SPS
maxRefreshPlaylistIntervalSecs	priv_aamp.h	/^	float maxRefreshPlaylistIntervalSecs;$/;"	m	class:PrivateInstanceAAMP
mbDownloadsBlocked	priv_aamp.h	/^	bool mbDownloadsBlocked;$/;"	m	class:PrivateInstanceAAMP
mbTrackDownloadsBlocked	priv_aamp.h	/^	bool mbTrackDownloadsBlocked[AAMP_TRACK_COUNT];$/;"	m	class:PrivateInstanceAAMP
mediaCount	fragmentcollector_hls.h	/^	int mediaCount;									\/**< Number of media in the stream *\/$/;"	m	class:StreamAbstractionAAMP_HLS
mediaError	main_aamp.h	/^		} mediaError;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon18
mediaInfo	fragmentcollector_hls.h	/^	MediaInfo mediaInfo[MAX_PROFILE];				\/**< Array to store multiple media within stream *\/$/;"	m	class:StreamAbstractionAAMP_HLS
mediaTrackBucketTypes	fragmentcollector_hls.cpp	/^static const ProfilerBucketType mediaTrackBucketTypes[AAMP_TRACK_COUNT] =$/;"	v	file:
mediaTrackDecryptBucketTypes	fragmentcollector_hls.cpp	/^static const ProfilerBucketType mediaTrackDecryptBucketTypes[AAMP_TRACK_COUNT] =$/;"	v	file:
mediaType	fragmentcollector_mpd.cpp	/^	MediaType mediaType;$/;"	m	class:MediaStreamContext	file:
mediaType2Bucket	main_aamp.cpp	/^ProfilerBucketType PrivateInstanceAAMP::mediaType2Bucket(MediaType fileType)$/;"	f	class:PrivateInstanceAAMP
media_stream	aampgstplayer.cpp	/^struct media_stream$/;"	s	file:
metadata	main_aamp.h	/^		} metadata;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon14
mfirstTuneFmt	priv_aamp.h	/^	int mfirstTuneFmt;			\/\/First Tune Format HLS(0) or DASH(1)$/;"	m	class:PrivateInstanceAAMP
minVODCacheSeconds	priv_aamp.h	/^	int minVODCacheSeconds;                 \/**< Minimum VOD caching duration in seconds*\/$/;"	m	class:GlobalConfigAAMP
mpStreamAbstractionAAMP	priv_aamp.h	/^	class StreamAbstractionAAMP *mpStreamAbstractionAAMP; \/\/ HLS or MPD collector$/;"	m	class:PrivateInstanceAAMP	typeref:class:PrivateInstanceAAMP::StreamAbstractionAAMP
mpd	fragmentcollector_mpd.cpp	/^	dash::mpd::IMPD *mpd;$/;"	m	class:PrivateStreamAbstractionMPD	file:
mpdDiscontinuityHandling	priv_aamp.h	/^	bool mpdDiscontinuityHandling;          \/**< Enable MPD discontinuity handling*\/$/;"	m	class:GlobalConfigAAMP
mpdDiscontinuityHandlingCdvr	priv_aamp.h	/^	bool mpdDiscontinuityHandlingCdvr;      \/**< Enable MPD discontinuity handling for CDVR*\/$/;"	m	class:GlobalConfigAAMP
mpdHarvestLimit	priv_aamp.h	/^	int mpdHarvestLimit;                     \/**< How many static mpds to be saved to box, 0 means none*\/$/;"	m	class:GlobalConfigAAMP
msg	main_aamp.h	/^			char msg[MAX_ANOMALY_BUFF_SIZE];$/;"	m	struct:AAMPEvent::__anon9::__anon10
msleep	tsprocessor.cpp	/^bool TSProcessor::msleep(long long throttleDiff)$/;"	f	class:TSProcessor
mutex	StreamAbstractionAAMP.h	/^	pthread_mutex_t mutex;              \/**< protection of track variables accessed from multiple threads *\/$/;"	m	class:MediaTrack
mystrpbrk	fragmentcollector_hls.cpp	/^static char *mystrpbrk(char *ptr)$/;"	f	file:
n_audio	aampgstplayer.cpp	/^	gint n_audio; \/\/Number of audio tracks.$/;"	m	struct:AAMPGstPlayerPriv	file:
name	StreamAbstractionAAMP.h	/^	const char* name;                   \/**< Track name used for debugging*\/$/;"	m	class:MediaTrack
name	fragmentcollector_hls.h	/^	const char *name;		\/**< Name of Media *\/$/;"	m	struct:MediaInfo
name	main_aamp.cpp	/^	std::string name;$/;"	m	struct:ChannelInfo	file:
need_data	aampgstplayer.cpp	/^static void need_data(GstElement *source, guint size, AAMPGstPlayer * _this)$/;"	f	file:
networkBandwidth	priv_aamp.h	/^	long networkBandwidth;$/;"	m	struct:AAMPAbrInfo
newTune	fragmentcollector_hls.h	/^	bool newTune;									\/**< Flag to indicate new tune  *\/$/;"	m	class:StreamAbstractionAAMP_HLS
nextMediaSequenceNumber	fragmentcollector_hls.h	/^	long long nextMediaSequenceNumber; \/**< media sequence number following current fragment-of-interest *\/$/;"	m	class:TrackState
noFog	priv_aamp.h	/^	bool noFog;                 \/**< Disable FOG*\/$/;"	m	class:GlobalConfigAAMP
notifiedCachingComplete	StreamAbstractionAAMP.h	/^	bool notifiedCachingComplete;       \/**< Fragment caching completed or not*\/$/;"	m	class:MediaTrack
nullPFrameHeader	tsprocessor.cpp	/^static unsigned char nullPFrameHeader[] =$/;"	v	file:
numBits	tsprocessor.cpp	/^	int numBits;$/;"	m	struct:MBAddrIncCode	file:
numPtsErrors	main_aamp.cpp	/^	int numPtsErrors;$/;"	m	struct:__anon4	file:
numberOfFragmentsCached	StreamAbstractionAAMP.h	/^	int numberOfFragmentsCached;        \/**< Number of fragments cached in this track*\/$/;"	m	class:MediaTrack
pAAMP	main_aamp.cpp	/^	PrivateInstanceAAMP* pAAMP;$/;"	m	struct:__anon4	file:
pFragmentInfo	fragmentcollector_hls.h	/^	const char *pFragmentInfo;				\/**< Fragment Information pointer *\/$/;"	m	struct:IndexNode
pMediaStreamContext	fragmentcollector_mpd.cpp	/^	struct MediaStreamContext *pMediaStreamContext;$/;"	m	struct:FragmentDownloadParams	typeref:struct:FragmentDownloadParams::MediaStreamContext	file:
pMediaStreamContext	fragmentcollector_mpd.cpp	/^	struct MediaStreamContext *pMediaStreamContext;$/;"	m	struct:HeaderFetchParams	typeref:struct:HeaderFetchParams::MediaStreamContext	file:
pNext	priv_aamp.h	/^	ListenerData* pNext;                \/**< Next listener *\/$/;"	m	struct:ListenerData
packetCount	tsprocessor.cpp	/^	int packetCount;$/;"	m	class:Demuxer	file:
pendingPlayState	aampgstplayer.cpp	/^	bool pendingPlayState; \/\/Flag that denotes if set pipeline to PLAYING state is pending.$/;"	m	struct:AAMPGstPlayerPriv	file:
periodId	fragmentcollector_mpd.cpp	/^	std::string periodId;$/;"	m	struct:PeriodInfo	file:
periodicProgressCallbackIdleTaskId	aampgstplayer.cpp	/^	guint periodicProgressCallbackIdleTaskId; \/\/ID of timed handler created for notifying progress events.$/;"	m	struct:AAMPGstPlayerPriv	file:
pes_header	tsprocessor.cpp	/^	GrowableBuffer pes_header;$/;"	m	class:Demuxer	file:
pes_header_ext_len	tsprocessor.cpp	/^	int pes_header_ext_len;$/;"	m	class:Demuxer	file:
pes_header_ext_read	tsprocessor.cpp	/^	int pes_header_ext_read;$/;"	m	class:Demuxer	file:
pes_state	tsprocessor.cpp	/^	int pes_state;$/;"	m	class:Demuxer	file:
picOrderCountType	tsprocessor.h	/^         int picOrderCountType;$/;"	m	struct:TSProcessor::_H264SPS
pid	tsprocessor.h	/^	int pid;$/;"	m	struct:RecordingComponent
pipeline	aampgstplayer.cpp	/^	GstElement *pipeline; \/\/GstPipeline used for playback.$/;"	m	struct:AAMPGstPlayerPriv	file:
pipeline_paused	priv_aamp.h	/^	bool pipeline_paused; \/\/ true if pipeline is paused$/;"	m	class:PrivateInstanceAAMP
playContext	fragmentcollector_hls.h	/^	TSProcessor* playContext; \/**< state for s\/w demuxer \/ pts\/pcr restamper module *\/$/;"	m	class:TrackState
playStartUTCMS	priv_aamp.h	/^	long long playStartUTCMS;$/;"	m	class:PrivateInstanceAAMP
playTarget	fragmentcollector_hls.h	/^	double playTarget; \/**< initially relative seek time (seconds) based on playlist window, but updated as a play_target *\/$/;"	m	class:TrackState
playTargetOffset	fragmentcollector_hls.h	/^	double playTargetOffset; \/**< For correcting timestamps of streams with audio and video tracks *\/$/;"	m	class:TrackState
playbackSpeed	main_aamp.h	/^			float playbackSpeed;        \/**< current trick speed (1.0 for normal play rate) *\/$/;"	m	struct:AAMPEvent::__anon9::__anon11
playingLastPeriod	fragmentcollector_mpd.cpp	/^	bool playingLastPeriod;$/;"	m	struct:FragmentDownloadParams	file:
playlist	fragmentcollector_hls.h	/^	GrowableBuffer playlist; 				\/**< downloaded playlist contents *\/$/;"	m	class:TrackState
playlistPosition	fragmentcollector_hls.h	/^	double playlistPosition; \/**< playlist-relative time of most recent fragment-of-interest; -1 if undefined *\/$/;"	m	class:TrackState
playlistType	fragmentcollector_hls.h	/^	PlaylistType playlistType;						\/**< Playlist Type *\/$/;"	m	class:StreamAbstractionAAMP_HLS
playlistUrl	fragmentcollector_hls.h	/^	char playlistUrl[MAX_URI_LENGTH]; 		\/**< uri associated with downloaded playlist *\/$/;"	m	class:TrackState
playlistsParallelFetch	priv_aamp.h	/^	bool playlistsParallelFetch;            \/**< Enabled parallel fetching of audio & video playlists*\/$/;"	m	class:GlobalConfigAAMP
position	StreamAbstractionAAMP.h	/^	double position;            \/**< Position in the playlist *\/$/;"	m	struct:CachedFragment
position	fragmentcollector_hls.h	/^	double position;	         \/**< Time of index from start *\/$/;"	m	struct:DiscontinuityIndexNode
position	tsprocessor.cpp	/^	double position;$/;"	m	class:Demuxer	file:
positionMiliseconds	main_aamp.h	/^			double positionMiliseconds; \/**< current play\/pause position relative to tune time - starts at zero) *\/$/;"	m	struct:AAMPEvent::__anon9::__anon11
prLicenseServerURL	priv_aamp.h	/^	char *prLicenseServerURL;               \/**< Playready License server URL*\/$/;"	m	class:GlobalConfigAAMP
preferredDrm	priv_aamp.h	/^	DRMSystems preferredDrm;                \/**< Preferred DRM*\/$/;"	m	class:GlobalConfigAAMP
prefetchIframePlaylist	priv_aamp.h	/^	bool prefetchIframePlaylist;            \/**< Enabled prefetching of I-Frame playlist*\/$/;"	m	class:GlobalConfigAAMP
prevBufferStatus	StreamAbstractionAAMP.h	/^	BufferHealthStatus prevBufferStatus; \/**< Previous buffer status of the track*\/$/;"	m	class:MediaTrack
previousAudioType	priv_aamp.h	/^	AudioType previousAudioType; \/* Used to maintain previous audio type *\/$/;"	m	class:PrivateInstanceAAMP
print_nop	tsprocessor.cpp	/^void print_nop(const char *format, ...){}$/;"	f
print_tag	aampgstplayer.cpp	/^static void print_tag( const GstTagList * list, const gchar * tag, gpointer user_data)$/;"	f	file:
privateContext	aampgstplayer.h	/^	struct AAMPGstPlayerPriv *privateContext;$/;"	m	class:AAMPGstPlayer	typeref:struct:AAMPGstPlayer::AAMPGstPlayerPriv
processBuffer	tsprocessor.cpp	/^bool TSProcessor::processBuffer(unsigned char *buffer, int size, bool &insPatPmt)$/;"	f	class:TSProcessor
processPMTSection	tsprocessor.cpp	/^void TSProcessor::processPMTSection(unsigned char* section, int sectionLength)$/;"	f	class:TSProcessor
processPacket	tsprocessor.cpp	/^	void processPacket(unsigned char * packetStart, bool &basePtsUpdated, bool &ptsError)$/;"	f	class:Demuxer
processPictureParameterSet	tsprocessor.cpp	/^void TSProcessor::processPictureParameterSet(unsigned char *p, int length)$/;"	f	class:TSProcessor
processScalingList	tsprocessor.cpp	/^void TSProcessor::processScalingList(unsigned char *& p, int& mask, int size)$/;"	f	class:TSProcessor
processSeqParameterSet	tsprocessor.cpp	/^bool TSProcessor::processSeqParameterSet(unsigned char *p, int length)$/;"	f	class:TSProcessor
processStartCode	tsprocessor.cpp	/^bool TSProcessor::processStartCode(unsigned char *buffer, bool& keepScanning, int length, int base)$/;"	f	class:TSProcessor
profileChanged	fragmentcollector_mpd.cpp	/^	bool profileChanged;$/;"	m	class:MediaStreamContext	file:
profileIdxForBandwidthNotification	StreamAbstractionAAMP.h	/^	int profileIdxForBandwidthNotification; \/**< internal - profile index for bandwidth change notification*\/$/;"	m	class:StreamAbstractionAAMP
profileIndex	StreamAbstractionAAMP.h	/^	int profileIndex;           \/**< Profile index; Updated internally *\/$/;"	m	struct:CachedFragment
profiler	priv_aamp.h	/^	ProfileEventAAMP profiler;$/;"	m	class:PrivateInstanceAAMP
programDateTime	fragmentcollector_hls.h	/^	const char* programDateTime; \/**Program Date time *\/$/;"	m	struct:DiscontinuityIndexNode
program_id	fragmentcollector_hls.h	/^	long program_id;	\/**< Program Id *\/$/;"	m	struct:HlsStreamInfo
progress	main_aamp.h	/^		} progress;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon11
progress	priv_aamp.h	/^	bool progress;   \/**< Download progress logs*\/$/;"	m	class:AampLogManager
progress_callback	main_aamp.cpp	/^static int progress_callback($/;"	f	file:
protectionEvent	aampgstplayer.cpp	/^	GstEvent *protectionEvent; \/\/GstEvent holding the pssi data to be sent downstream.$/;"	m	struct:AAMPGstPlayerPriv	file:
ptr	priv_aamp.h	/^	char *ptr;      \/**< Pointer to buffer's memory location *\/$/;"	m	struct:GrowableBuffer
ptsCheckForEosOnUnderflowIdleTaskId	aampgstplayer.cpp	/^	guint ptsCheckForEosOnUnderflowIdleTaskId; \/\/ID of task to ensure video PTS is not moving before notifying EOS on underflow.$/;"	m	struct:AAMPGstPlayerPriv	file:
ptsError	StreamAbstractionAAMP.h	/^	bool ptsError;                      \/**< flag to indicate if last injected fragment has ptsError *\/$/;"	m	class:MediaTrack
ptsErrorThreshold	priv_aamp.h	/^	int ptsErrorThreshold;                       \/**< Max number of back-to-back PTS errors within designated time*\/$/;"	m	class:GlobalConfigAAMP
ptsUpdatedTimeMS	aampgstplayer.cpp	/^	long long ptsUpdatedTimeMS; \/\/Timestamp when PTS was last updated$/;"	m	struct:AAMPGstPlayerPriv	file:
putBits	tsprocessor.cpp	/^void TSProcessor::putBits(unsigned char *& p, int& mask, int bitCount, unsigned int value)$/;"	f	class:TSProcessor
putPmtByte	tsprocessor.cpp	/^void TSProcessor::putPmtByte(unsigned char* &pmt, int& index, unsigned char byte, int pmtPid)$/;"	f	class:TSProcessor
rate	aampgstplayer.cpp	/^	int rate; \/\/Current playback rate.$/;"	m	struct:AAMPGstPlayerPriv	file:
rate	fragmentcollector_hls.h	/^	float rate;										\/**< Rate of playback  *\/$/;"	m	class:StreamAbstractionAAMP_HLS
rate	fragmentcollector_mpd.cpp	/^	float rate;$/;"	m	class:PrivateStreamAbstractionMPD	file:
rate	main_aamp.h	/^			int rate; \/**< Playback rate *\/$/;"	m	struct:AAMPEvent::__anon9::__anon12
rate	priv_aamp.h	/^	int rate; \/\/ most recent (non-zero) play rate for non-paused content$/;"	m	class:PrivateInstanceAAMP
reTimestamp	tsprocessor.cpp	/^void TSProcessor::reTimestamp(unsigned char *&packet, int length)$/;"	f	class:TSProcessor
reTune	main_aamp.cpp	/^	bool reTune;$/;"	m	struct:__anon4	file:
readPCR	tsprocessor.cpp	/^long long TSProcessor::readPCR(unsigned char *p)$/;"	f	class:TSProcessor
readTimeStamp	tsprocessor.cpp	/^bool TSProcessor::readTimeStamp(unsigned char *p, long long& TS)$/;"	f	class:TSProcessor
refreshPlaylist	fragmentcollector_hls.h	/^	bool refreshPlaylist;	\/**< bool flag to indicate if playlist refresh required or not *\/$/;"	m	class:TrackState
replace	fragmentcollector_mpd.cpp	/^static int replace(std::string& str, const std::string& from, const std::string& toString )$/;"	f	file:
replace	fragmentcollector_mpd.cpp	/^static int replace(std::string& str, const std::string& from, uint64_t toNumber )$/;"	f	file:
replace_cstring	main_aamp.cpp	/^static bool replace_cstring( char *string, const char *existingSubStringToReplace, const char *replacementString )$/;"	f	file:
reportProgressInterval	priv_aamp.h	/^	int reportProgressInterval;             \/**< Interval of progress reporting*\/$/;"	m	class:GlobalConfigAAMP
representation	fragmentcollector_mpd.cpp	/^	IRepresentation *representation;$/;"	m	class:MediaStreamContext	file:
representationIndex	fragmentcollector_mpd.cpp	/^	int representationIndex;$/;"	m	class:MediaStreamContext	file:
reset	tsprocessor.cpp	/^	void reset()$/;"	f	class:Demuxer
reset	tsprocessor.cpp	/^void TSProcessor::reset()$/;"	f	class:TSProcessor
resetPosition	aampgstplayer.cpp	/^	bool resetPosition;$/;"	m	struct:media_stream	file:
resolution	StreamAbstractionAAMP.h	/^	StreamResolution resolution;    \/**< Resolution of the stream*\/$/;"	m	struct:StreamInfo
responseCode	main_aamp.h	/^			long responseCode;$/;"	m	struct:AAMPEvent::__anon9::__anon19
responseHeaderData	main_aamp.cpp	/^	httpRespHeaderData *responseHeaderData;$/;"	m	struct:CurlCallbackContext	file:
result	priv_aamp.h	/^		int result;                 \/**< Event result *\/$/;"	m	class:ProfileEventAAMP::TuneEvent
rmf_osal_memcpy	tsprocessor.cpp	561;"	d	file:
seekPosition	fragmentcollector_hls.h	/^	double seekPosition;							\/**< Seek position for playback *\/$/;"	m	class:StreamAbstractionAAMP_HLS
seekPosition	fragmentcollector_mpd.cpp	/^	double seekPosition;$/;"	m	class:PrivateStreamAbstractionMPD	file:
seek_pos_seconds	priv_aamp.h	/^	double seek_pos_seconds; \/\/ indicates the playback position at which most recent playback activity began$/;"	m	class:PrivateInstanceAAMP
segDLFailCount	StreamAbstractionAAMP.h	/^	int segDLFailCount;                 \/**< Segment download fail count*\/$/;"	m	class:MediaTrack
segDLFailCount	fragmentcollector_hls.h	/^	int segDLFailCount;						\/**< Segment Download fail count *\/$/;"	m	class:StreamAbstractionAAMP_HLS
segDrmDecryptFailCount	StreamAbstractionAAMP.h	/^	int segDrmDecryptFailCount;         \/**< Segment decryption failure count*\/$/;"	m	class:MediaTrack
segDrmDecryptFailCount	fragmentcollector_hls.h	/^	int segDrmDecryptFailCount;				\/**< Segment Decrypt fail count *\/$/;"	m	class:StreamAbstractionAAMP_HLS
send	tsprocessor.cpp	/^	void send()$/;"	f	class:Demuxer	file:
sendDiscontinuity	tsprocessor.cpp	/^void TSProcessor::sendDiscontinuity(double position)$/;"	f	class:TSProcessor
sendQueuedSegment	tsprocessor.cpp	/^void TSProcessor::sendQueuedSegment(long long basepts, double updatedStartPositon)$/;"	f	class:TSProcessor
sendSegment	tsprocessor.cpp	/^bool TSProcessor::sendSegment(char *segment, size_t& size, double position, double duration, bool discontinuous, bool &ptsError)$/;"	f	class:TSProcessor
sendTuneMetrics	main_aamp.cpp	/^void PrivateInstanceAAMP::sendTuneMetrics(bool success)$/;"	f	class:PrivateInstanceAAMP
sentESCount	tsprocessor.cpp	/^	int sentESCount;$/;"	m	class:Demuxer	file:
separateColorPlaneFlag	tsprocessor.h	/^         int separateColorPlaneFlag;$/;"	m	struct:TSProcessor::_H264SPS
setBasePTS	tsprocessor.cpp	/^	void setBasePTS(unsigned long long basePTS, bool final)$/;"	f	class:Demuxer
setBasePTS	tsprocessor.cpp	/^void TSProcessor::setBasePTS(double position, long long pts)$/;"	f	class:TSProcessor
setCurrentDrm	priv_aamp.h	/^	void setCurrentDrm(DRMSystems drm) { mCurrentDrm = drm; }$/;"	f	class:PrivateInstanceAAMP
setFrameRateForTM	tsprocessor.h	/^      void setFrameRateForTM( int frameRate)$/;"	f	class:TSProcessor
setLogAndCfgDirectory	aamplogging.cpp	/^void AampLogManager::setLogAndCfgDirectory(char driveName)$/;"	f	class:AampLogManager
setLogLevel	aamplogging.cpp	/^void AampLogManager::setLogLevel(AAMP_LogLevel newLevel)$/;"	f	class:AampLogManager
setPlayMode	tsprocessor.cpp	/^void TSProcessor::setPlayMode(PlayMode mode)$/;"	f	class:TSProcessor
setRate	tsprocessor.cpp	/^void TSProcessor::setRate(double rate, PlayMode mode)$/;"	f	class:TSProcessor
setThrottleEnable	tsprocessor.cpp	/^void TSProcessor::setThrottleEnable(bool enable)$/;"	f	class:TSProcessor
setVolumeOrMuteUnMute	aampgstplayer.cpp	/^void AAMPGstPlayer::setVolumeOrMuteUnMute(void)$/;"	f	class:AAMPGstPlayer
setupThrottle	tsprocessor.cpp	/^void TSProcessor::setupThrottle(int segmentDurationMsSigned)$/;"	f	class:TSProcessor
severity	main_aamp.h	/^			int severity; \/**< informative number indicates severity of msg, e.g Warning, Error, Trace etc *\/$/;"	m	struct:AAMPEvent::__anon9::__anon10
shouldRetry	main_aamp.h	/^			bool shouldRetry;                                   \/**< If recovery on retry is possible *\/$/;"	m	struct:AAMPEvent::__anon9::__anon18
siType	tsprocessor.h	/^	int siType;$/;"	m	struct:RecordingComponent
sinkbin	aampgstplayer.cpp	/^	GstElement *sinkbin;$/;"	m	struct:media_stream	file:
source	aampgstplayer.cpp	/^	GstElement *source;$/;"	m	struct:media_stream	file:
speedChanged	main_aamp.h	/^		} speedChanged;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon12
speedsChanged	main_aamp.h	/^		} speedsChanged;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon22
spsId	tsprocessor.h	/^         int spsId;$/;"	m	struct:TSProcessor::_H264PPS
ssl_callback	main_aamp.cpp	/^CURLcode ssl_callback(CURL *curl, void *ssl_ctx, void *user_ptr)$/;"	f
stallErrorCode	priv_aamp.h	/^	int stallErrorCode;                     \/**< Stall error code*\/$/;"	m	class:GlobalConfigAAMP
stallTimeoutInMS	priv_aamp.h	/^	int stallTimeoutInMS;                   \/**< Stall timeout in milliseconds*\/$/;"	m	class:GlobalConfigAAMP
start	priv_aamp.h	/^		unsigned int start;         \/**< Event start time *\/$/;"	m	class:ProfileEventAAMP::TuneEvent
startMiliseconds	main_aamp.h	/^			double startMiliseconds;    \/**< time shift buffer start position (relative to tune time - starts at zero) *\/$/;"	m	struct:AAMPEvent::__anon9::__anon11
startTime	fragmentcollector_mpd.cpp	/^	uint64_t startTime;$/;"	m	struct:PeriodInfo	file:
startTimeForPlaylistSync	fragmentcollector_hls.h	/^	struct timeval startTimeForPlaylistSync; \/**< used for time-based track synchronization when switching between playlists *\/$/;"	m	class:TrackState	typeref:struct:TrackState::timeval
startswith	fragmentcollector_hls.cpp	/^static bool startswith(char **pstring, const char *prefix)$/;"	f	file:
state	main_aamp.h	/^			PrivAAMPState state;        \/**< Player state *\/$/;"	m	struct:AAMPEvent::__anon9::__anon20
stateChanged	main_aamp.h	/^		} stateChanged;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon20
strAAMPPipeName	main_aamp.cpp	/^static const char* strAAMPPipeName = "\/tmp\/ipc_aamp";$/;"	v	file:
stream	aampgstplayer.cpp	/^	media_stream stream[AAMP_TRACK_COUNT];$/;"	m	struct:AAMPGstPlayerPriv	file:
streamInfo	fragmentcollector_hls.h	/^	HlsStreamInfo streamInfo[MAX_PROFILE];			\/**< Array to store multiple stream information *\/$/;"	m	class:StreamAbstractionAAMP_HLS
streamOutputFormat	fragmentcollector_hls.h	/^	StreamOutputFormat streamOutputFormat; \/**< type of data encoded in each fragment *\/$/;"	m	class:TrackState
stream_type	fragmentcollector_mpd.cpp	/^	MediaType stream_type;$/;"	m	struct:DrmSessionParams	file:
streamerIsActive	priv_aamp.h	/^	bool streamerIsActive;$/;"	m	class:PrivateInstanceAAMP
subscribedTags	priv_aamp.h	/^	std::vector<std::string> subscribedTags;$/;"	m	class:PrivateInstanceAAMP
subtitles	fragmentcollector_hls.h	/^	const char *subtitles;	\/**< Subtitles *\/$/;"	m	struct:HlsStreamInfo
supportedSpeedCount	main_aamp.h	/^			int supportedSpeedCount;                                        \/**< Supported playback speed count *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
supportedSpeedCount	main_aamp.h	/^			int supportedSpeedCount;                            \/**< Supported playback speed count *\/$/;"	m	struct:AAMPEvent::__anon9::__anon22
supportedSpeeds	main_aamp.h	/^			int supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];                 \/**< Supported playback speeds *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
supportedSpeeds	main_aamp.h	/^			int supportedSpeeds[MAX_SUPPORTED_SPEED_COUNT];     \/**< Supported playback speeds *\/$/;"	m	struct:AAMPEvent::__anon9::__anon22
szContent	main_aamp.h	/^			const char* szContent;      \/**< Metadata content *\/$/;"	m	struct:AAMPEvent::__anon9::__anon16
szEventType	main_aamp.h	/^			const char* szEventType;    \/**< Event Type *\/$/;"	m	struct:AAMPEvent::__anon9::__anon17
szName	main_aamp.h	/^			const char* szName;         \/**< Metadata name *\/$/;"	m	struct:AAMPEvent::__anon9::__anon16
tFinish	priv_aamp.h	/^		unsigned int tFinish;   \/**< Relative end time of operation, based on tuneStartMonotonicBase *\/$/;"	m	struct:ProfileEventAAMP::ProfilerBucket
tStart	priv_aamp.h	/^		unsigned int tStart;    \/**< Relative start time of operation, based on tuneStartMonotonicBase *\/$/;"	m	struct:ProfileEventAAMP::ProfilerBucket
targetDnldPosition	fragmentcollector_mpd.cpp	/^	double targetDnldPosition;$/;"	m	class:MediaStreamContext	file:
targetDurationSeconds	fragmentcollector_hls.h	/^	double targetDurationSeconds; \/**< copy of \\#EXT-X-TARGETDURATION to manage playlist refresh frequency *\/$/;"	m	class:TrackState
throttle	tsprocessor.cpp	/^bool TSProcessor::throttle()$/;"	f	class:TSProcessor
time	main_aamp.h	/^			int time;                   \/**< Playback time *\/$/;"	m	struct:AAMPEvent::__anon9::__anon13
timeLineIndex	fragmentcollector_mpd.cpp	/^	int timeLineIndex;$/;"	m	class:MediaStreamContext	file:
timeMilliseconds	main_aamp.h	/^			double timeMilliseconds;    \/**< Playback position - relative to tune time - starts at zero *\/$/;"	m	struct:AAMPEvent::__anon9::__anon16
timedMetadata	main_aamp.h	/^		} timedMetadata;$/;"	m	union:AAMPEvent::__anon9	typeref:struct:AAMPEvent::__anon9::__anon16
timedMetadata	priv_aamp.h	/^	std::vector<TimedMetadata> timedMetadata;$/;"	m	class:PrivateInstanceAAMP
totalFetchedDuration	StreamAbstractionAAMP.h	/^	double totalFetchedDuration;        \/**< Total fragment fetched duration*\/$/;"	m	class:MediaTrack
totalFragmentsDownloaded	StreamAbstractionAAMP.h	/^	int totalFragmentsDownloaded;       \/**< Total fragments downloaded since start by track*\/$/;"	m	class:MediaTrack
totalInjectedDuration	StreamAbstractionAAMP.h	/^	double totalInjectedDuration;       \/**< Total fragment injected duration*\/$/;"	m	class:MediaTrack
total_bytes	aampgstplayer.cpp	/^	guint64 total_bytes;$/;"	m	struct:AAMPGstPlayerPriv	file:
trace	priv_aamp.h	/^	bool trace;      \/**< Trace level*\/$/;"	m	class:AampLogManager
traceprintf	priv_aamp.h	210;"	d
traceprintf	priv_aamp.h	212;"	d
trackState	fragmentcollector_hls.h	/^	TrackState* trackState[AAMP_TRACK_COUNT];		\/**< Array to store all tracks of a stream *\/$/;"	m	class:StreamAbstractionAAMP_HLS
trickStartUTCMS	priv_aamp.h	/^	long long trickStartUTCMS;$/;"	m	class:PrivateInstanceAAMP
trickmode	tsprocessor.cpp	/^	bool trickmode;$/;"	m	class:Demuxer	file:
trickplayMode	StreamAbstractionAAMP.h	/^	bool trickplayMode;                     \/**< trick play flag to be updated by subclasses*\/$/;"	m	class:StreamAbstractionAAMP
trim	main_aamp.cpp	/^static void trim(char **cmd)$/;"	f	file:
tuneEventList	priv_aamp.h	/^	std::list<TuneEvent> tuneEventList;     \/**< List of events happened during tuning *\/$/;"	m	class:ProfileEventAAMP
tuneEventListMtx	priv_aamp.h	/^	std::mutex tuneEventListMtx;            \/**< Mutex protecting tuneEventList *\/$/;"	m	class:ProfileEventAAMP
tuneFailure	main_aamp.h	/^	AAMPTuneFailure tuneFailure;    \/**< Failure ID *\/$/;"	m	struct:TuneFailureMap
tuneFailureMap	main_aamp.cpp	/^static TuneFailureMap tuneFailureMap[] =$/;"	v	file:
tuneStartBaseUTCMS	priv_aamp.h	/^	long long tuneStartBaseUTCMS;           \/**< common UTC base for start of tune *\/$/;"	m	class:ProfileEventAAMP
tuneStartMonotonicBase	priv_aamp.h	/^	long long tuneStartMonotonicBase;       \/**< Base time from Monotonic clock for interval calculation *\/$/;"	m	class:ProfileEventAAMP
tunedEventConfigLive	priv_aamp.h	/^	TunedEventConfig tunedEventConfigLive;  \/**< When to send TUNED event for LIVE*\/$/;"	m	class:GlobalConfigAAMP
tunedEventConfigVOD	priv_aamp.h	/^	TunedEventConfig tunedEventConfigVOD;   \/**< When to send TUNED event for VOD*\/$/;"	m	class:GlobalConfigAAMP
tunedManifestUrl	priv_aamp.h	/^	char tunedManifestUrl[MAX_URI_LENGTH];$/;"	m	class:PrivateInstanceAAMP
type	StreamAbstractionAAMP.h	/^	TrackType type;                     \/**< Media type of the track*\/$/;"	m	class:MediaTrack
type	fragmentcollector_hls.h	/^	MediaType type;			\/**< Media Type *\/$/;"	m	struct:MediaInfo
type	main_aamp.h	/^	AAMPEventType type; 		\/**< Event type *\/$/;"	m	struct:AAMPEvent
type	priv_aamp.h	/^	    unsigned int type;$/;"	m	struct:PrivateInstanceAAMP::_AAMP2ReceiverMsg
type	priv_aamp.h	/^	int type;             \/**< Header type *\/$/;"	m	struct:httpRespHeaderData
type	tsprocessor.cpp	/^	MediaType type;$/;"	m	class:Demuxer	file:
updatePATPMT	tsprocessor.cpp	/^void TSProcessor::updatePATPMT()$/;"	f	class:TSProcessor
uri	StreamAbstractionAAMP.h	/^	char uri[MAX_URI_LENGTH];   \/**< Fragment url *\/$/;"	m	struct:CachedFragment
uri	fragmentcollector_hls.h	/^	const char *uri;		\/**< URI Information *\/$/;"	m	struct:MediaInfo
uri	fragmentcollector_hls.h	/^	const char *uri;	\/**< URI Information *\/$/;"	m	struct:HlsStreamInfo
uri	main_aamp.cpp	/^	std::string uri;$/;"	m	struct:ChannelInfo	file:
using_playersinkbin	aampgstplayer.cpp	/^	gboolean using_playersinkbin;$/;"	m	struct:media_stream	file:
using_westerossink	aampgstplayer.cpp	/^	bool using_westerossink; \/\/true if westros sink is used as video sink$/;"	m	struct:AAMPGstPlayerPriv	file:
validateStateWithMsTimeout	aampgstplayer.cpp	/^static GstState validateStateWithMsTimeout( AAMPGstPlayer *_this, GstState stateToValidate, guint msTimeOut)$/;"	f	file:
videoComponentCount	tsprocessor.h	/^      int videoComponentCount, audioComponentCount, dataComponentCount;$/;"	m	class:TSProcessor
videoComponents	tsprocessor.h	/^      RecordingComponent videoComponents[MAX_PIDS], audioComponents[MAX_PIDS], dataComponents[MAX_PIDS];$/;"	m	class:TSProcessor
videoFormatMap	fragmentcollector_hls.cpp	/^static const FormatMap videoFormatMap[AAMP_VIDEO_FORMAT_MAP_LEN] =$/;"	v	file:
videoMuted	aampgstplayer.cpp	/^	bool videoMuted; \/\/Video mute status.$/;"	m	struct:AAMPGstPlayerPriv	file:
videoRectangle	aampgstplayer.cpp	/^	char videoRectangle[32]; \/\/Video-rectangle co-ordinates in format x,y,w,h.$/;"	m	struct:AAMPGstPlayerPriv	file:
video_dec	aampgstplayer.cpp	/^	GstElement *video_dec; \/\/Video decoder used by pipeline.$/;"	m	struct:AAMPGstPlayerPriv	file:
video_muted	priv_aamp.h	/^	bool video_muted;$/;"	m	class:PrivateInstanceAAMP
video_pproc	aampgstplayer.cpp	/^	GstElement *video_pproc; \/\/Video element used by pipeline.(only for Intel).$/;"	m	struct:AAMPGstPlayerPriv	file:
video_sink	aampgstplayer.cpp	/^	GstElement *video_sink; \/\/Video sink used by pipeline.$/;"	m	struct:AAMPGstPlayerPriv	file:
vodTrickplayFPS	priv_aamp.h	/^	int vodTrickplayFPS;                    \/**< Trickplay frames per second for VOD*\/$/;"	m	class:GlobalConfigAAMP
vodTrickplayFPSLocalOverride	priv_aamp.h	/^	bool vodTrickplayFPSLocalOverride;      \/**< Enabled VOD Trickplay FPS local overriding*\/$/;"	m	class:GlobalConfigAAMP
width	StreamAbstractionAAMP.h	/^	int width;      \/**< Width in pixels*\/$/;"	m	struct:StreamResolution
width	main_aamp.h	/^			int width;                                                      \/**< Maximum video width *\/$/;"	m	struct:AAMPEvent::__anon9::__anon14
width	main_aamp.h	/^			int width;                  \/**< Video width *\/$/;"	m	struct:AAMPEvent::__anon9::__anon13
writePCR	tsprocessor.cpp	/^void TSProcessor::writePCR(unsigned char *p, long long PCR, bool clearExtension)$/;"	f	class:TSProcessor
writeTimeStamp	tsprocessor.cpp	/^void TSProcessor::writeTimeStamp(unsigned char *p, int prefix, long long TS)$/;"	f	class:TSProcessor
write_callback	main_aamp.cpp	/^static size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata)$/;"	f	file:
wvLicenseServerURL	priv_aamp.h	/^	char *wvLicenseServerURL;               \/**< Widevine License server URL*\/$/;"	m	class:GlobalConfigAAMP
xreTimeBuckets	priv_aamp.h	/^	long long xreTimeBuckets[TuneTimeMax];  \/**< Start time of each buckets for classic metrics conversion *\/$/;"	m	class:ProfileEventAAMP
zoom	aampgstplayer.cpp	/^	VideoZoomMode zoom; \/\/Video-zoom setting.$/;"	m	struct:AAMPGstPlayerPriv	file:
zoom_mode	priv_aamp.h	/^	VideoZoomMode zoom_mode;$/;"	m	class:PrivateInstanceAAMP
~AAMPEventListener	main_aamp.h	/^	virtual ~AAMPEventListener(){};$/;"	f	class:AAMPEventListener
~AAMPGstPlayer	aampgstplayer.cpp	/^AAMPGstPlayer::~AAMPGstPlayer()$/;"	f	class:AAMPGstPlayer
~Demuxer	tsprocessor.cpp	/^	~Demuxer()$/;"	f	class:Demuxer
~GlobalConfigAAMP	priv_aamp.h	/^	~GlobalConfigAAMP(){}$/;"	f	class:GlobalConfigAAMP
~MediaStreamContext	fragmentcollector_mpd.cpp	/^	~MediaStreamContext(){}$/;"	f	class:MediaStreamContext
~MediaTrack	streamabstraction.cpp	/^MediaTrack::~MediaTrack()$/;"	f	class:MediaTrack
~PlayerInstanceAAMP	main_aamp.cpp	/^PlayerInstanceAAMP::~PlayerInstanceAAMP()$/;"	f	class:PlayerInstanceAAMP
~PrivateInstanceAAMP	main_aamp.cpp	/^PrivateInstanceAAMP::~PrivateInstanceAAMP()$/;"	f	class:PrivateInstanceAAMP
~PrivateStreamAbstractionMPD	fragmentcollector_mpd.cpp	/^PrivateStreamAbstractionMPD::~PrivateStreamAbstractionMPD(void)$/;"	f	class:PrivateStreamAbstractionMPD
~ProfileEventAAMP	priv_aamp.h	/^	~ProfileEventAAMP(){}$/;"	f	class:ProfileEventAAMP
~StreamAbstractionAAMP	streamabstraction.cpp	/^StreamAbstractionAAMP::~StreamAbstractionAAMP()$/;"	f	class:StreamAbstractionAAMP
~StreamAbstractionAAMP_HLS	fragmentcollector_hls.cpp	/^StreamAbstractionAAMP_HLS::~StreamAbstractionAAMP_HLS()$/;"	f	class:StreamAbstractionAAMP_HLS
~StreamAbstractionAAMP_MPD	fragmentcollector_mpd.cpp	/^StreamAbstractionAAMP_MPD::~StreamAbstractionAAMP_MPD()$/;"	f	class:StreamAbstractionAAMP_MPD
~StreamSink	main_aamp.h	/^	virtual ~StreamSink(){};$/;"	f	class:StreamSink
~TSProcessor	tsprocessor.cpp	/^TSProcessor::~TSProcessor()$/;"	f	class:TSProcessor
~TrackState	fragmentcollector_hls.cpp	/^TrackState::~TrackState()$/;"	f	class:TrackState
